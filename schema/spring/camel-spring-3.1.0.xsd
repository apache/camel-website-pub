<?xml version="1.0" encoding="UTF-8"?><xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://camel.apache.org/schema/spring" elementFormDefault="qualified" targetNamespace="http://camel.apache.org/schema/spring" version="1.0">

  <xs:element name="aggregate" type="tns:aggregateDefinition"/>

  <xs:element name="any23" type="tns:any23DataFormat"/>

  <xs:element name="apiKey" type="tns:restSecurityApiKey"/>

  <xs:element name="asn1" type="tns:asn1DataFormat"/>

  <xs:element name="avro" type="tns:avroDataFormat"/>

  <xs:element name="barcode" type="tns:barcodeDataFormat"/>

  <xs:element name="base64" type="tns:base64DataFormat"/>

  <xs:element name="basicAuth" type="tns:restSecurityBasicAuth"/>

  <xs:element name="batch-config" type="tns:batchResequencerConfig"/>

  <xs:element name="bean" type="tns:beanDefinition"/>

  <xs:element name="beanPostProcessor" type="tns:camelBeanPostProcessor">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Spring specific DefaultCamelBeanPostProcessor which uses Spring
BeanPostProcessor to post process beans.
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="beanio" type="tns:beanioDataFormat"/>

  <xs:element name="bindy" type="tns:bindyDataFormat"/>

  <xs:element name="blacklistServiceFilter" type="tns:blacklistServiceCallServiceFilterConfiguration"/>

  <xs:element name="cachingServiceDiscovery" type="tns:cachingServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="camelContext" type="tns:camelContextFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
CamelContext using XML configuration.
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="cbor" type="tns:cborDataFormat"/>

  <xs:element name="choice" type="tns:choiceDefinition"/>

  <xs:element name="circuitBreaker" type="tns:circuitBreakerDefinition"/>

  <xs:element name="claimCheck" type="tns:claimCheckDefinition"/>

  <xs:element name="combinedServiceDiscovery" type="tns:combinedServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="combinedServiceFilter" type="tns:combinedServiceCallServiceFilterConfiguration"/>

  <xs:element name="constant" type="tns:constantExpression"/>

  <xs:element name="consulServiceDiscovery" type="tns:consulServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="consumerTemplate" type="tns:camelConsumerTemplateFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configures a ConsumerTemplate
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="contextScan" type="tns:contextScanDefinition"/>

  <xs:element name="convertBodyTo" type="tns:convertBodyDefinition"/>

  <xs:element name="crypto" type="tns:cryptoDataFormat"/>

  <xs:element name="csv" type="tns:csvDataFormat"/>

  <xs:element name="customDataFormat" type="tns:customDataFormat"/>

  <xs:element name="customLoadBalancer" type="tns:customLoadBalancerDefinition"/>

  <xs:element name="customServiceFilter" type="tns:customServiceCallServiceFilterConfiguration"/>

  <xs:element name="dataFormats" type="tns:dataFormatsDefinition"/>

  <xs:element name="defaultLoadBalancer" type="tns:defaultServiceCallServiceLoadBalancerConfiguration"/>

  <xs:element name="delay" type="tns:delayDefinition"/>

  <xs:element name="delete" type="tns:deleteVerbDefinition"/>

  <xs:element name="description" type="tns:descriptionDefinition"/>

  <xs:element name="dnsServiceDiscovery" type="tns:dnsServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="doCatch" type="tns:catchDefinition"/>

  <xs:element name="doFinally" type="tns:finallyDefinition"/>

  <xs:element name="doTry" type="tns:tryDefinition"/>

  <xs:element name="dynamicRouter" type="tns:dynamicRouterDefinition"/>

  <xs:element name="endpoint" type="tns:camelEndpointFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Camel endpoint configuration
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="enrich" type="tns:enrichDefinition"/>

  <xs:element name="errorHandler" type="tns:errorHandlerDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Error handler settings
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="etcdServiceDiscovery" type="tns:etcdServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="exchangeProperty" type="tns:exchangePropertyExpression"/>

  <xs:element name="export" type="tns:camelServiceExporterDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Used for export a service using Spring Remoting to hide the network call using
an interface.
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="expression" type="tns:expressionSubElementDefinition"/>

  <xs:element name="expressionDefinition" type="tns:expression"/>

  <xs:element name="failover" type="tns:failoverLoadBalancerDefinition"/>

  <xs:element name="fhirJson" type="tns:fhirJsonDataFormat"/>

  <xs:element name="fhirXml" type="tns:fhirXmlDataFormat"/>

  <xs:element name="filter" type="tns:filterDefinition"/>

  <xs:element name="flatpack" type="tns:flatpackDataFormat"/>

  <xs:element name="fluentTemplate" type="tns:camelFluentProducerTemplateFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configures a org.apache.camel.FluentProducerTemplate
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="from" type="tns:fromDefinition"/>

  <xs:element name="get" type="tns:getVerbDefinition"/>

  <xs:element name="globalOption" type="tns:globalOptionDefinition"/>

  <xs:element name="globalOptions" type="tns:globalOptionsDefinition"/>

  <xs:element name="grok" type="tns:grokDataFormat"/>

  <xs:element name="groovy" type="tns:groovyExpression"/>

  <xs:element name="gzipdeflater" type="tns:gzipDataFormat"/>

  <xs:element name="head" type="tns:headVerbDefinition"/>

  <xs:element name="header" type="tns:headerExpression"/>

  <xs:element name="healthyServiceFilter" type="tns:healthyServiceCallServiceFilterConfiguration"/>

  <xs:element name="hl7" type="tns:hl7DataFormat"/>

  <xs:element name="hl7terser" type="tns:hl7TerserExpression"/>

  <xs:element name="hystrixConfiguration" type="tns:hystrixConfigurationDefinition"/>

  <xs:element name="ical" type="tns:icalDataFormat"/>

  <xs:element name="idempotentConsumer" type="tns:idempotentConsumerDefinition"/>

  <xs:element name="inOnly" type="tns:inOnlyDefinition"/>

  <xs:element name="inOut" type="tns:inOutDefinition"/>

  <xs:element name="inputType" type="tns:inputTypeDefinition"/>

  <xs:element name="intercept" type="tns:interceptDefinition"/>

  <xs:element name="interceptFrom" type="tns:interceptFromDefinition"/>

  <xs:element name="interceptSendToEndpoint" type="tns:interceptSendToEndpointDefinition"/>

  <xs:element name="jacksonxml" type="tns:jacksonXMLDataFormat"/>

  <xs:element name="jaxb" type="tns:jaxbDataFormat"/>

  <xs:element name="jmxAgent" type="tns:camelJMXAgentDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
JMX configuration.
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="json" type="tns:jsonDataFormat"/>

  <xs:element name="jsonApi" type="tns:jsonApiDataFormat"/>

  <xs:element name="jsonpath" type="tns:jsonPathExpression"/>

  <xs:element name="keyStoreParameters" type="tns:keyStoreParametersFactoryBean"/>

  <xs:element name="kubernetesServiceDiscovery" type="tns:kubernetesServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="language" type="tns:languageExpression"/>

  <xs:element name="loadBalance" type="tns:loadBalanceDefinition"/>

  <xs:element name="loadBalancerConfiguration" type="tns:serviceCallServiceLoadBalancerConfiguration"/>

  <xs:element name="log" type="tns:logDefinition"/>

  <xs:element name="loop" type="tns:loopDefinition"/>

  <xs:element name="lzf" type="tns:lzfDataFormat"/>

  <xs:element name="marshal" type="tns:marshalDefinition"/>

  <xs:element name="method" type="tns:methodCallExpression"/>

  <xs:element name="mime-multipart" type="tns:mimeMultipartDataFormat"/>

  <xs:element name="multicast" type="tns:multicastDefinition"/>

  <xs:element name="mvel" type="tns:mvelExpression"/>

  <xs:element name="oauth2" type="tns:restSecurityOAuth2"/>

  <xs:element name="ognl" type="tns:ognlExpression"/>

  <xs:element name="onCompletion" type="tns:onCompletionDefinition"/>

  <xs:element name="onException" type="tns:onExceptionDefinition"/>

  <xs:element name="onFallback" type="tns:onFallbackDefinition"/>

  <xs:element name="optimisticLockRetryPolicy" type="tns:optimisticLockRetryPolicyDefinition"/>

  <xs:element name="otherwise" type="tns:otherwiseDefinition"/>

  <xs:element name="outputType" type="tns:outputTypeDefinition"/>

  <xs:element name="packageScan" type="tns:packageScanDefinition"/>

  <xs:element name="param" type="tns:restOperationParamDefinition"/>

  <xs:element name="passThroughServiceFilter" type="tns:passThroughServiceCallServiceFilterConfiguration"/>

  <xs:element name="patch" type="tns:patchVerbDefinition"/>

  <xs:element name="pgp" type="tns:pgpDataFormat"/>

  <xs:element name="pipeline" type="tns:pipelineDefinition"/>

  <xs:element name="policy" type="tns:policyDefinition"/>

  <xs:element name="pollEnrich" type="tns:pollEnrichDefinition"/>

  <xs:element name="post" type="tns:postVerbDefinition"/>

  <xs:element name="process" type="tns:processDefinition"/>

  <xs:element name="propertiesFunction" type="tns:camelPropertyPlaceholderFunctionDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Function to use with properties placeholder
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="propertiesLocation" type="tns:camelPropertyPlaceholderLocationDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Properties to use with properties placeholder
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="property" type="tns:propertyDefinition"/>

  <xs:element name="propertyPlaceholder" type="tns:camelPropertyPlaceholderDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Properties placeholder
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="protobuf" type="tns:protobufDataFormat"/>

  <xs:element name="proxy" type="tns:camelProxyFactoryDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
To proxy a service call using a interface
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="put" type="tns:putVerbDefinition"/>

  <xs:element name="random" type="tns:randomLoadBalancerDefinition"/>

  <xs:element name="recipientList" type="tns:recipientListDefinition"/>

  <xs:element name="redeliveryPolicy" type="tns:redeliveryPolicyDefinition"/>

  <xs:element name="redeliveryPolicyProfile" type="tns:camelRedeliveryPolicyFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configuration of redelivery policy.
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="ref" type="tns:refExpression"/>

  <xs:element name="removeHeader" type="tns:removeHeaderDefinition"/>

  <xs:element name="removeHeaders" type="tns:removeHeadersDefinition"/>

  <xs:element name="removeProperties" type="tns:removePropertiesDefinition"/>

  <xs:element name="removeProperty" type="tns:removePropertyDefinition"/>

  <xs:element name="resequence" type="tns:resequenceDefinition"/>

  <xs:element name="resilience4jConfiguration" type="tns:resilience4JConfigurationDefinition"/>

  <xs:element name="responseHeader" type="tns:restOperationResponseHeaderDefinition"/>

  <xs:element name="responseMessage" type="tns:restOperationResponseMsgDefinition"/>

  <xs:element name="rest" type="tns:restDefinition"/>

  <xs:element name="restBinding" type="tns:restBindingDefinition"/>

  <xs:element name="restConfiguration" type="tns:restConfigurationDefinition"/>

  <xs:element name="restContext" type="tns:camelRestContextFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configuration of REST services using rest-dsl using XML
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="restContextRef" type="tns:restContextRefDefinition"/>

  <xs:element name="restProperty" type="tns:restPropertyDefinition"/>

  <xs:element name="rests" type="tns:restsDefinition"/>

  <xs:element name="ribbonLoadBalancer" type="tns:ribbonServiceCallServiceLoadBalancerConfiguration"/>

  <xs:element name="rollback" type="tns:rollbackDefinition"/>

  <xs:element name="roundRobin" type="tns:roundRobinLoadBalancerDefinition"/>

  <xs:element name="route" type="tns:routeDefinition"/>

  <xs:element name="routeBuilder" type="tns:routeBuilderDefinition"/>

  <xs:element name="routeContext" type="tns:camelRouteContextFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configuration of routes using XML
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="routeContextRef" type="tns:routeContextRefDefinition"/>

  <xs:element name="routes" type="tns:routesDefinition"/>

  <xs:element name="routingSlip" type="tns:routingSlipDefinition"/>

  <xs:element name="rss" type="tns:rssDataFormat"/>

  <xs:element name="saga" type="tns:sagaDefinition"/>

  <xs:element name="sample" type="tns:samplingDefinition"/>

  <xs:element name="script" type="tns:scriptDefinition"/>

  <xs:element name="secureRandomParameters" type="tns:secureRandomParametersFactoryBean"/>

  <xs:element name="secureXML" type="tns:xmlSecurityDataFormat"/>

  <xs:element name="security" type="tns:securityDefinition"/>

  <xs:element name="securityDefinitions" type="tns:restSecuritiesDefinition"/>

  <xs:element name="serviceCall" type="tns:serviceCallDefinition"/>

  <xs:element name="serviceCallConfiguration" type="tns:serviceCallConfigurationDefinition"/>

  <xs:element name="serviceChooserConfiguration" type="tns:serviceCallServiceChooserConfiguration"/>

  <xs:element name="serviceDiscoveryConfiguration" type="tns:serviceCallServiceDiscoveryConfiguration"/>

  <xs:element name="serviceExpression" type="tns:serviceCallExpressionConfiguration"/>

  <xs:element name="serviceFilterConfiguration" type="tns:serviceCallServiceFilterConfiguration"/>

  <xs:element name="setBody" type="tns:setBodyDefinition"/>

  <xs:element name="setExchangePattern" type="tns:setExchangePatternDefinition"/>

  <xs:element name="setHeader" type="tns:setHeaderDefinition"/>

  <xs:element name="setProperty" type="tns:setPropertyDefinition"/>

  <xs:element name="simple" type="tns:simpleExpression"/>

  <xs:element name="soapjaxb" type="tns:soapJaxbDataFormat"/>

  <xs:element name="sort" type="tns:sortDefinition"/>

  <xs:element name="spel" type="tns:spELExpression"/>

  <xs:element name="split" type="tns:splitDefinition"/>

  <xs:element name="sslContextParameters" type="tns:sslContextParametersFactoryBean"/>

  <xs:element name="staticServiceDiscovery" type="tns:staticServiceCallServiceDiscoveryConfiguration"/>

  <xs:element name="step" type="tns:stepDefinition"/>

  <xs:element name="sticky" type="tns:stickyLoadBalancerDefinition"/>

  <xs:element name="stop" type="tns:stopDefinition"/>

  <xs:element name="stream-config" type="tns:streamResequencerConfig"/>

  <xs:element name="streamCaching" type="tns:camelStreamCachingStrategyDefinition">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Stream caching configuration.
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="syslog" type="tns:syslogDataFormat"/>

  <xs:element name="tarfile" type="tns:tarFileDataFormat"/>

  <xs:element name="template" type="tns:camelProducerTemplateFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configures a ProducerTemplate
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="threadPool" type="tns:camelThreadPoolFactoryBean">
    <xs:annotation>
      <xs:documentation xml:lang="en"><![CDATA[
Configuration of thread pools
      ]]></xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:element name="threadPoolProfile" type="tns:threadPoolProfileDefinition"/>

  <xs:element name="threads" type="tns:threadsDefinition"/>

  <xs:element name="thrift" type="tns:thriftDataFormat"/>

  <xs:element name="throttle" type="tns:throttleDefinition"/>

  <xs:element name="throwException" type="tns:throwExceptionDefinition"/>

  <xs:element name="tidyMarkup" type="tns:tidyMarkupDataFormat"/>

  <xs:element name="to" type="tns:toDefinition"/>

  <xs:element name="toD" type="tns:toDynamicDefinition"/>

  <xs:element name="tokenize" type="tns:tokenizerExpression"/>

  <xs:element name="topic" type="tns:topicLoadBalancerDefinition"/>

  <xs:element name="transacted" type="tns:transactedDefinition"/>

  <xs:element name="transform" type="tns:transformDefinition"/>

  <xs:element name="transformers" type="tns:transformersDefinition"/>

  <xs:element name="typeFilter" type="tns:yamlTypeFilterDefinition"/>

  <xs:element name="univocity-csv" type="tns:uniVocityCsvDataFormat"/>

  <xs:element name="univocity-fixed" type="tns:uniVocityFixedWidthDataFormat"/>

  <xs:element name="univocity-header" type="tns:uniVocityHeader"/>

  <xs:element name="univocity-tsv" type="tns:uniVocityTsvDataFormat"/>

  <xs:element name="unmarshal" type="tns:unmarshalDefinition"/>

  <xs:element name="validate" type="tns:validateDefinition"/>

  <xs:element name="validators" type="tns:validatorsDefinition"/>

  <xs:element name="verb" type="tns:verbDefinition"/>

  <xs:element name="weighted" type="tns:weightedLoadBalancerDefinition"/>

  <xs:element name="when" type="tns:whenDefinition"/>

  <xs:element name="whenSkipSendToEndpoint" type="tns:whenSkipSendToEndpointDefinition"/>

  <xs:element name="wireTap" type="tns:wireTapDefinition"/>

  <xs:element name="xmlrpc" type="tns:xmlRpcDataFormat"/>

  <xs:element name="xpath" type="tns:xPathExpression"/>

  <xs:element name="xquery" type="tns:xQueryExpression"/>

  <xs:element name="xstream" type="tns:xStreamDataFormat"/>

  <xs:element name="xtokenize" type="tns:xmlTokenizerExpression"/>

  <xs:element name="yaml" type="tns:yamlDataFormat"/>

  <xs:element name="zipdeflater" type="tns:zipDeflaterDataFormat"/>

  <xs:element name="zipfile" type="tns:zipFileDataFormat"/>

  <xs:element name="zookeeperServiceDiscovery" type="tns:zooKeeperServiceCallServiceDiscoveryConfiguration"/>

  <xs:complexType abstract="true" name="abstractCamelConsumerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="maximumCacheSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a custom maximum cache size to use in the backing cache pools.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="camelContextId" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Id of CamelContext to use if there are multiple CamelContexts in the same JVM.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="identifiedType">
    <xs:sequence/>
    <xs:attribute name="id" type="xs:ID">
      <xs:annotation>
        <xs:documentation xml:lang="en"><![CDATA[
The id of this node.
        ]]></xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelEndpointFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:property"/>
        </xs:sequence>
        <xs:attribute name="uri" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the URI to use to resolve the endpoint. Notice that additional options can
be configured using a series of property.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="propertyDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required"/>
    <xs:attribute name="value" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelFluentProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="defaultEndpoint" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the default endpoint URI used by default for sending message exchanges.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maximumCacheSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a custom maximum cache size to use in the backing cache pools.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="defaultEndpoint" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the default endpoint URI used by default for sending message exchanges.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maximumCacheSize" type="xs:int">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a custom maximum cache size to use in the backing cache pools.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelRedeliveryPolicyFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="maximumRedeliveries" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the maximum number of times a message exchange will be redelivered. Setting
a negative value will retry forever.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="redeliveryDelay" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the maximum redelivery delay. Use -1 if you wish to have no maximum.
Default value: 1000
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="asyncDelayedRedelivery" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether asynchronous delayed redelivery is allowed. This is disabled by
default. When enabled it allows Camel to schedule a future task for delayed
redelivery which prevents current thread from blocking while waiting. Exchange
which is transacted will however always use synchronous delayed redelivery
because the transaction must execute in the same thread context. Default value:
false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="backOffMultiplier" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the multiplier used to increase the delay between redeliveries if
useExponentialBackOff is enabled. Default value: 2
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useExponentialBackOff" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Enables/disables exponential backoff using the backOffMultiplier to increase the
time between retries. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="collisionAvoidanceFactor" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the factor used for collision avoidance if enabled via
useCollisionAvoidance. Default value: 0.15
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useCollisionAvoidance" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Enables/disables collision avoidance which adds some randomization to the
backoff timings to reduce contention probability. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maximumRedeliveryDelay" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the maximum redelivery delay. Use -1 if you wish to have no maximum.
Default value: 60000
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="retriesExhaustedLogLevel" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the logging level to use for log messages when retries have been exhausted.
Default value: ERROR
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="retryAttemptedLogLevel" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the logging level to use for log messages when retries are attempted.
Default value: DEBUG
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="retryAttemptedLogInterval" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the interval for log messages when retries are attempted. Default value: 0
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logRetryAttempted" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether to log retry attempts. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logStackTrace" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether stack traces should be logged or not. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logRetryStackTrace" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether stack traces should be logged or not. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logHandled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether errors should be logged even if its handled. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logNewException" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether errors should be logged when a new exception occurred during
handling a previous exception. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logContinued" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether errors should be logged even if its continued. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logExhausted" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether exhausted exceptions should be logged or not. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logExhaustedMessageHistory" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether to log exhausted errors including message history. Default value:
false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logExhaustedMessageBody" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether exhausted message body/headers should be logged with message
history included. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="disableRedelivery" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Disables redelivery by setting maximum redeliveries to 0. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delayPattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets an optional delay pattern to use instead of fixed delay.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Controls whether to allow redelivery while stopping/shutting down a route that
uses error handling. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="exchangeFormatterRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to
generate the log message from exchange.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractCamelThreadPoolFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
        <xs:attribute name="poolSize" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the core pool size (threads to keep minimum in pool).
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxPoolSize" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the maximum pool size.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keepAliveTime" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the keep alive time for inactive threads.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeUnit" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the time unit used for keep alive time. Default value: SECONDS
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxQueueSize" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the maximum number of tasks in the work queue. Use -1 for an unbounded
queue.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowCoreThreadTimeOut" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether to allow core threads to timeout.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rejectedPolicy" type="tns:threadPoolRejectedPolicy">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the handler for tasks which cannot be executed by the thread pool. Default
value: CallerRuns
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="threadName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
To use a custom thread name / pattern.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="scheduled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether to use a scheduled thread pool. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelJMXAgentDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="disabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Disable JMI (default false). Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onlyRegisterProcessorWithCustomId" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Only register processor if a custom id was defined for it. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="registryPort" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
RMI connector registry port (default 1099). Default value: 1099
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="connectorPort" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
RMI connector server port (default -1 not used). Default value: -1
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mbeanServerDefaultDomain" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
MBean server default domain name (default org.apache.camel). Default value:
org.apache.camel
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mbeanObjectDomainName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
MBean object domain name (default org.apache.camel). Default value:
org.apache.camel
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="serviceUrlPath" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
JMX Service URL path (default /jmxrmi). Default value: /jmxrmi
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="createConnector" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether the agent should be created. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="usePlatformMBeanServer" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether the platform mbean server should be used. Default
value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="registerAlways" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether to register mbeans always. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="registerNewRoutes" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether to register mbeans when starting new routes.
Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statisticsLevel" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Level of granularity for performance statistics enabled. Default value: Default
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="loadStatisticsEnabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether Load statistics is enabled. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="endpointRuntimeStatisticsEnabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether endpoint runtime statistics is enabled. Default
value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="includeHostName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether to include hostname in JMX MBean names. Default
value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useHostIPAddress" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether to use hostname or IP Address in the service url.
Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mask" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A flag that indicates whether to remove detected sensitive information (such as
passwords) from MBean names and attributes. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelPropertyPlaceholderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:propertiesFunction"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:propertiesLocation"/>
        </xs:sequence>
        <xs:attribute name="location" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
A list of locations to load properties. You can use comma to separate multiple
locations. This option will override any default locations and only use the
locations from this option.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="encoding" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Encoding to use when loading properties file from the file system or classpath.
If no encoding has been set, then the properties files is loaded using
ISO-8859-1 encoding (latin-1) as documented by
java.util.Properties#load(java.io.InputStream).
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreMissingLocation" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether to silently ignore if a location cannot be located, such as a properties
file not found. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="propertiesParserRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Reference to a custom PropertiesParser to be used.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="defaultFallbackEnabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
If false, the component does not attempt to find a default for the key by
looking after the colon separator. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelPropertyPlaceholderFunctionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Reference to the custom properties function to lookup in the registry.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelPropertyPlaceholderLocationDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="resolver" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The resolver to use to locate the location. Default value: classpath
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Property locations to use.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="optional" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
If the location is optional. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProxyFactoryDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="serviceUrl" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The camel endpoint uri used to send the message to when calling the service from
the interface.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="serviceInterface" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Java interfaces to use as facade for the service to be proxied.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="camelContextId" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The id of the CamelContext to use, if there is multiple CamelContext in the same
JVM.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelServiceExporterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Camel endpoint uri to use a remote transport when calling the service.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="serviceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Reference to the service name to lookup in the registry.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="method" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Name of method to invoke on service.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="serviceInterface" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Java interfaces to use as facade for the service to be exported.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="camelContextId" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The id of the CamelContext to use, if there is multiple CamelContext in the same
JVM.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelStreamCachingStrategyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="enabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether the stream caching is enabled. Notice: This cannot be changed at
runtime. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="spoolDirectory" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the spool (temporary) directory to use for overflow and spooling to disk.
If no spool directory has been explicit configured, then a temporary directory
is created in the java.io.tmpdir directory.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="spoolCipher" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a cipher name to use when spooling to disk to write with encryption. By
default the data is not encrypted.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="spoolThreshold" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Threshold in bytes when overflow to disk is activated. The default threshold is
org.apache.camel.StreamCache#DEFAULT_SPOOL_THRESHOLD bytes (eg 128kb). Use -1 to
disable overflow to disk.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="spoolUsedHeapMemoryThreshold" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a percentage (1-99) of used heap memory threshold to activate spooling to
disk.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="spoolUsedHeapMemoryLimit" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets what the upper bounds should be when spoolUsedHeapMemoryThreshold is in
use.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="spoolRules" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Reference to one or more custom
org.apache.camel.spi.StreamCachingStrategy.SpoolRule to use. Multiple rules can
be separated by comma.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bufferSize" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the buffer size to use when allocating in-memory buffers used for in-memory
stream caches. The default size is
org.apache.camel.util.IOHelper#DEFAULT_BUFFER_SIZE.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="removeSpoolDirectoryWhenStopping" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether to remove the temporary directory when stopping. This option is default
true. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statisticsEnabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether statistics is enabled.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="anySpoolRules" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether if just any of the
org.apache.camel.spi.StreamCachingStrategy.SpoolRule rules returns true then
shouldSpoolCache(long) returns true. If this option is false, then all the
org.apache.camel.spi.StreamCachingStrategy.SpoolRule must return true. The
default value is false which means that all the rules must return true. Default
value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="patternBasedPackageScanFilter">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractJsseUtilFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractKeyManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="keyPassword" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="algorithm" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractKeyStoreParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="resource" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractSecureRandomParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="algorithm" type="xs:string" use="required"/>
        <xs:attribute name="provider" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="abstractTrustManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:sequence/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="algorithm" type="xs:string"/>
        <xs:attribute name="trustManager" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="cipherSuitesParameters">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="cipherSuite" nillable="true" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="filterParameters">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="include" nillable="true" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="exclude" nillable="true" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="sniHostNames">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="sniHostName" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="secureSocketProtocolsParameters">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="secureSocketProtocol" nillable="true" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="output">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="processorDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="inheritErrorHandler" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="optionalIdentifiedDefinition">
    <xs:sequence>
      <xs:element minOccurs="0" ref="tns:description"/>
    </xs:sequence>
    <xs:attribute name="customId" type="xs:boolean"/>
    <xs:attribute name="id" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="descriptionDefinition">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="lang" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="aggregateDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="completionPredicate" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="completionTimeoutExpression" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="completionSizeExpression" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" ref="tns:optimisticLockRetryPolicy"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="parallelProcessing" type="xs:string"/>
        <xs:attribute name="optimisticLocking" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="timeoutCheckerExecutorServiceRef" type="xs:string"/>
        <xs:attribute name="aggregationRepositoryRef" type="xs:string"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
        <xs:attribute name="strategyMethodAllowNull" type="xs:string"/>
        <xs:attribute name="completionSize" type="xs:string"/>
        <xs:attribute name="completionInterval" type="xs:string"/>
        <xs:attribute name="completionTimeout" type="xs:string"/>
        <xs:attribute name="completionTimeoutCheckerInterval" type="xs:string"/>
        <xs:attribute name="completionFromBatchConsumer" type="xs:string"/>
        <xs:attribute name="completionOnNewCorrelationGroup" type="xs:string"/>
        <xs:attribute name="eagerCheckCompletion" type="xs:string"/>
        <xs:attribute name="ignoreInvalidCorrelationKeys" type="xs:string"/>
        <xs:attribute name="closeCorrelationKeyOnCompletion" type="xs:string"/>
        <xs:attribute name="discardOnCompletionTimeout" type="xs:string"/>
        <xs:attribute name="discardOnAggregationFailure" type="xs:string"/>
        <xs:attribute name="forceCompletionOnStop" type="xs:string"/>
        <xs:attribute name="completeAllOnStop" type="xs:string"/>
        <xs:attribute name="aggregateControllerRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="expressionSubElementDefinition">
    <xs:choice>
      <xs:element ref="tns:expressionDefinition"/>
      <xs:element ref="tns:constant"/>
      <xs:element ref="tns:exchangeProperty"/>
      <xs:element ref="tns:groovy"/>
      <xs:element ref="tns:header"/>
      <xs:element ref="tns:hl7terser"/>
      <xs:element ref="tns:jsonpath"/>
      <xs:element ref="tns:language"/>
      <xs:element ref="tns:method"/>
      <xs:element ref="tns:mvel"/>
      <xs:element ref="tns:ognl"/>
      <xs:element ref="tns:ref"/>
      <xs:element ref="tns:simple"/>
      <xs:element ref="tns:spel"/>
      <xs:element ref="tns:tokenize"/>
      <xs:element ref="tns:xtokenize"/>
      <xs:element ref="tns:xpath"/>
      <xs:element ref="tns:xquery"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="expression">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="trim" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="optimisticLockRetryPolicyDefinition">
    <xs:sequence/>
    <xs:attribute name="maximumRetries" type="xs:string"/>
    <xs:attribute name="retryDelay" type="xs:string"/>
    <xs:attribute name="maximumRetryDelay" type="xs:string"/>
    <xs:attribute name="exponentialBackOff" type="xs:string"/>
    <xs:attribute name="randomBackOff" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="beanDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="method" type="xs:string"/>
        <xs:attribute name="beanType" type="xs:string"/>
        <xs:attribute name="cache" type="xs:string"/>
        <xs:attribute name="scope" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="noOutputDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="catchDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
          <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="whenDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="choiceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
          </xs:choice>
          <xs:element minOccurs="0" ref="tns:otherwise"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="otherwiseDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="circuitBreakerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element minOccurs="0" ref="tns:hystrixConfiguration"/>
          <xs:element minOccurs="0" ref="tns:resilience4jConfiguration"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="configurationRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="hystrixConfigurationDefinition">
    <xs:complexContent>
      <xs:extension base="tns:hystrixConfigurationCommon">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="hystrixConfigurationCommon">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="groupKey" type="xs:string"/>
        <xs:attribute name="threadPoolKey" type="xs:string"/>
        <xs:attribute name="circuitBreakerEnabled" type="xs:string"/>
        <xs:attribute name="circuitBreakerErrorThresholdPercentage" type="xs:string"/>
        <xs:attribute name="circuitBreakerForceClosed" type="xs:string"/>
        <xs:attribute name="circuitBreakerForceOpen" type="xs:string"/>
        <xs:attribute name="circuitBreakerRequestVolumeThreshold" type="xs:string"/>
        <xs:attribute name="circuitBreakerSleepWindowInMilliseconds" type="xs:string"/>
        <xs:attribute name="executionIsolationSemaphoreMaxConcurrentRequests" type="xs:string"/>
        <xs:attribute name="executionIsolationStrategy" type="xs:string"/>
        <xs:attribute name="executionIsolationThreadInterruptOnTimeout" type="xs:string"/>
        <xs:attribute name="executionTimeoutInMilliseconds" type="xs:string"/>
        <xs:attribute name="executionTimeoutEnabled" type="xs:string"/>
        <xs:attribute name="fallbackIsolationSemaphoreMaxConcurrentRequests" type="xs:string"/>
        <xs:attribute name="fallbackEnabled" type="xs:string"/>
        <xs:attribute name="metricsHealthSnapshotIntervalInMilliseconds" type="xs:string"/>
        <xs:attribute name="metricsRollingPercentileBucketSize" type="xs:string"/>
        <xs:attribute name="metricsRollingPercentileEnabled" type="xs:string"/>
        <xs:attribute name="metricsRollingPercentileWindowInMilliseconds" type="xs:string"/>
        <xs:attribute name="metricsRollingPercentileWindowBuckets" type="xs:string"/>
        <xs:attribute name="metricsRollingStatisticalWindowInMilliseconds" type="xs:string"/>
        <xs:attribute name="metricsRollingStatisticalWindowBuckets" type="xs:string"/>
        <xs:attribute name="requestLogEnabled" type="xs:string"/>
        <xs:attribute name="corePoolSize" type="xs:string"/>
        <xs:attribute name="maximumSize" type="xs:string"/>
        <xs:attribute name="keepAliveTime" type="xs:string"/>
        <xs:attribute name="maxQueueSize" type="xs:string"/>
        <xs:attribute name="queueSizeRejectionThreshold" type="xs:string"/>
        <xs:attribute name="threadPoolRollingNumberStatisticalWindowInMilliseconds" type="xs:string"/>
        <xs:attribute name="threadPoolRollingNumberStatisticalWindowBuckets" type="xs:string"/>
        <xs:attribute name="allowMaximumSizeToDivergeFromCoreSize" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="resilience4JConfigurationDefinition">
    <xs:complexContent>
      <xs:extension base="tns:resilience4JConfigurationCommon">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="resilience4JConfigurationCommon">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element minOccurs="0" name="bulkheadEnabled" type="xs:string"/>
          <xs:element minOccurs="0" name="bulkheadMaxConcurrentCalls" type="xs:string"/>
          <xs:element minOccurs="0" name="bulkheadMaxWaitDuration" type="xs:string"/>
          <xs:element minOccurs="0" name="timeoutEnabled" type="xs:string"/>
          <xs:element minOccurs="0" name="timeoutExecutorServiceRef" type="xs:string"/>
          <xs:element minOccurs="0" name="timeoutDuration" type="xs:string"/>
          <xs:element minOccurs="0" name="timeoutCancelRunningFuture" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="circuitBreakerRef" type="xs:string"/>
        <xs:attribute name="configRef" type="xs:string"/>
        <xs:attribute name="failureRateThreshold" type="xs:string"/>
        <xs:attribute name="permittedNumberOfCallsInHalfOpenState" type="xs:string"/>
        <xs:attribute name="slidingWindowSize" type="xs:string"/>
        <xs:attribute name="slidingWindowType" type="xs:string"/>
        <xs:attribute name="minimumNumberOfCalls" type="xs:string"/>
        <xs:attribute name="writableStackTraceEnabled" type="xs:string"/>
        <xs:attribute name="waitDurationInOpenState" type="xs:string"/>
        <xs:attribute name="automaticTransitionFromOpenToHalfOpenEnabled" type="xs:string"/>
        <xs:attribute name="slowCallRateThreshold" type="xs:string"/>
        <xs:attribute name="slowCallDurationThreshold" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="claimCheckDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="operation" type="xs:string" use="required"/>
        <xs:attribute name="key" type="xs:string"/>
        <xs:attribute name="filter" type="xs:string"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="constants">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="contextScanDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="excludes" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="includes" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="includeNonSingletons" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="convertBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string" use="required"/>
        <xs:attribute name="charset" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormat">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="contentTypeHeader" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="delayDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="asyncDelayed" type="xs:string"/>
        <xs:attribute name="callerRunsWhenRejected" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dynamicRouterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="uriDelimiter" type="xs:string"/>
        <xs:attribute name="ignoreInvalidEndpoints" type="xs:string"/>
        <xs:attribute name="cacheSize" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="enrichDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
        <xs:attribute name="strategyMethodAllowNull" type="xs:string"/>
        <xs:attribute name="aggregateOnException" type="xs:string"/>
        <xs:attribute name="shareUnitOfWork" type="xs:string"/>
        <xs:attribute name="cacheSize" type="xs:string"/>
        <xs:attribute name="ignoreInvalidEndpoint" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="filterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="finallyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="fromDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="globalOptionDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required"/>
    <xs:attribute name="value" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="globalOptionsDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:globalOption"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="idempotentConsumerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="messageIdRepositoryRef" type="xs:string" use="required"/>
        <xs:attribute name="eager" type="xs:string"/>
        <xs:attribute name="completionEager" type="xs:string"/>
        <xs:attribute name="skipDuplicate" type="xs:string"/>
        <xs:attribute name="removeOnFailure" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOnlyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="sendDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOutDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inputTypeDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="urn" type="xs:string"/>
        <xs:attribute name="validate" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptFromDefinition">
    <xs:complexContent>
      <xs:extension base="tns:interceptDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptSendToEndpointDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="uri" type="xs:string" use="required"/>
        <xs:attribute name="skipSendToOriginalEndpoint" type="xs:string"/>
        <xs:attribute name="afterUri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalanceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:failover"/>
            <xs:element ref="tns:random"/>
            <xs:element ref="tns:customLoadBalancer"/>
            <xs:element ref="tns:roundRobin"/>
            <xs:element ref="tns:sticky"/>
            <xs:element ref="tns:topic"/>
            <xs:element ref="tns:weighted"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="failoverLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="exception" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="roundRobin" type="xs:string"/>
        <xs:attribute name="sticky" type="xs:string"/>
        <xs:attribute name="maximumFailoverAttempts" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalancer">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="randomLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="customLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="roundRobinLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stickyLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="topicLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="weightedLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
        <xs:attribute name="roundRobin" type="xs:string"/>
        <xs:attribute name="distributionRatio" type="xs:string" use="required"/>
        <xs:attribute name="distributionRatioDelimiter" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="logDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="message" type="xs:string" use="required"/>
        <xs:attribute name="loggingLevel" type="xs:string"/>
        <xs:attribute name="logName" type="xs:string"/>
        <xs:attribute name="marker" type="xs:string"/>
        <xs:attribute name="loggerRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="copy" type="xs:string"/>
        <xs:attribute name="doWhile" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="marshalDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:any23"/>
            <xs:element ref="tns:asn1"/>
            <xs:element ref="tns:avro"/>
            <xs:element ref="tns:barcode"/>
            <xs:element ref="tns:base64"/>
            <xs:element ref="tns:beanio"/>
            <xs:element ref="tns:bindy"/>
            <xs:element ref="tns:cbor"/>
            <xs:element ref="tns:crypto"/>
            <xs:element ref="tns:csv"/>
            <xs:element name="custom" type="tns:customDataFormat"/>
            <xs:element ref="tns:fhirJson"/>
            <xs:element ref="tns:fhirXml"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:grok"/>
            <xs:element name="gzip" type="tns:gzipDataFormat"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:ical"/>
            <xs:element ref="tns:jacksonxml"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:json"/>
            <xs:element ref="tns:jsonApi"/>
            <xs:element ref="tns:lzf"/>
            <xs:element name="mimeMultipart" type="tns:mimeMultipartDataFormat"/>
            <xs:element ref="tns:protobuf"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:soapjaxb"/>
            <xs:element ref="tns:syslog"/>
            <xs:element ref="tns:tarfile"/>
            <xs:element ref="tns:thrift"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:univocity-csv"/>
            <xs:element ref="tns:univocity-fixed"/>
            <xs:element ref="tns:univocity-tsv"/>
            <xs:element ref="tns:xmlrpc"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:pgp"/>
            <xs:element ref="tns:yaml"/>
            <xs:element name="zip" type="tns:zipDeflaterDataFormat"/>
            <xs:element ref="tns:zipfile"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="any23DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element minOccurs="0" name="configuration" type="tns:propertyDefinitions"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="extractors" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="outputFormat" type="xs:string"/>
        <xs:attribute name="baseURI" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="propertyDefinitions">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:property"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="asn1DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="usingIterator" type="xs:string"/>
        <xs:attribute name="clazzName" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="avroDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="instanceClassName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="barcodeDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="width" type="xs:string"/>
        <xs:attribute name="height" type="xs:string"/>
        <xs:attribute name="imageType" type="xs:string"/>
        <xs:attribute name="barcodeFormat" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="base64DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="lineLength" type="xs:string"/>
        <xs:attribute name="lineSeparator" type="xs:string"/>
        <xs:attribute name="urlSafe" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="beanioDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="mapping" type="xs:string" use="required"/>
        <xs:attribute name="streamName" type="xs:string" use="required"/>
        <xs:attribute name="ignoreUnidentifiedRecords" type="xs:string"/>
        <xs:attribute name="ignoreUnexpectedRecords" type="xs:string"/>
        <xs:attribute name="ignoreInvalidRecords" type="xs:string"/>
        <xs:attribute name="encoding" type="xs:string"/>
        <xs:attribute name="beanReaderErrorHandlerType" type="xs:string"/>
        <xs:attribute name="unmarshalSingleObject" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="bindyDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string" use="required"/>
        <xs:attribute name="classType" type="xs:string"/>
        <xs:attribute name="locale" type="xs:string"/>
        <xs:attribute name="unwrapSingleInstance" type="xs:string"/>
        <xs:attribute name="allowEmptyStream" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="cborDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="objectMapper" type="xs:string"/>
        <xs:attribute name="useDefaultObjectMapper" type="xs:string"/>
        <xs:attribute name="unmarshalTypeName" type="xs:string"/>
        <xs:attribute name="collectionTypeName" type="xs:string"/>
        <xs:attribute name="useList" type="xs:string"/>
        <xs:attribute name="allowUnmarshallType" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:string"/>
        <xs:attribute name="allowJmsType" type="xs:string"/>
        <xs:attribute name="enableFeatures" type="xs:string"/>
        <xs:attribute name="disableFeatures" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="cryptoDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="algorithm" type="xs:string"/>
        <xs:attribute name="cryptoProvider" type="xs:string"/>
        <xs:attribute name="keyRef" type="xs:string"/>
        <xs:attribute name="initVectorRef" type="xs:string"/>
        <xs:attribute name="algorithmParameterRef" type="xs:string"/>
        <xs:attribute name="buffersize" type="xs:string"/>
        <xs:attribute name="macAlgorithm" type="xs:string"/>
        <xs:attribute name="shouldAppendHMAC" type="xs:string"/>
        <xs:attribute name="inline" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="csvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="header" type="xs:string"/>
        </xs:sequence>
        <xs:attribute name="formatRef" type="xs:string"/>
        <xs:attribute name="formatName" type="xs:string"/>
        <xs:attribute name="commentMarkerDisabled" type="xs:string"/>
        <xs:attribute name="commentMarker" type="xs:string"/>
        <xs:attribute name="delimiter" type="xs:string"/>
        <xs:attribute name="escapeDisabled" type="xs:string"/>
        <xs:attribute name="escape" type="xs:string"/>
        <xs:attribute name="headerDisabled" type="xs:string"/>
        <xs:attribute name="allowMissingColumnNames" type="xs:string"/>
        <xs:attribute name="ignoreEmptyLines" type="xs:string"/>
        <xs:attribute name="ignoreSurroundingSpaces" type="xs:string"/>
        <xs:attribute name="nullStringDisabled" type="xs:string"/>
        <xs:attribute name="nullString" type="xs:string"/>
        <xs:attribute name="quoteDisabled" type="xs:string"/>
        <xs:attribute name="quote" type="xs:string"/>
        <xs:attribute name="recordSeparatorDisabled" type="xs:string"/>
        <xs:attribute name="recordSeparator" type="xs:string"/>
        <xs:attribute name="skipHeaderRecord" type="xs:string"/>
        <xs:attribute name="quoteMode" type="xs:string"/>
        <xs:attribute name="ignoreHeaderCase" type="xs:string"/>
        <xs:attribute name="trim" type="xs:string"/>
        <xs:attribute name="trailingDelimiter" type="xs:string"/>
        <xs:attribute name="marshallerFactoryRef" type="xs:string"/>
        <xs:attribute name="lazyLoad" type="xs:string"/>
        <xs:attribute name="useMaps" type="xs:string"/>
        <xs:attribute name="useOrderedMaps" type="xs:string"/>
        <xs:attribute name="recordConverterRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="customDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="fhirJsonDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:fhirDataformat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="fhirDataformat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="fhirVersion" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:string"/>
        <xs:attribute name="serverBaseUrl" type="xs:string"/>
        <xs:attribute name="omitResourceId" type="xs:string"/>
        <xs:attribute name="encodeElementsAppliesToChildResourcesOnly" type="xs:string"/>
        <xs:attribute name="encodeElements">
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="dontEncodeElements">
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="stripVersionsFromReferences" type="xs:string"/>
        <xs:attribute name="overrideResourceIdWithBundleEntryFullUrl" type="xs:string"/>
        <xs:attribute name="summaryMode" type="xs:string"/>
        <xs:attribute name="suppressNarratives" type="xs:string"/>
        <xs:attribute name="dontStripVersionsFromReferencesAtPaths">
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="fhirXmlDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:fhirDataformat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="flatpackDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="definition" type="xs:string"/>
        <xs:attribute name="fixed" type="xs:string"/>
        <xs:attribute name="ignoreFirstRecord" type="xs:string"/>
        <xs:attribute name="textQualifier" type="xs:string"/>
        <xs:attribute name="delimiter" type="xs:string"/>
        <xs:attribute name="allowShortLines" type="xs:string"/>
        <xs:attribute name="ignoreExtraColumns" type="xs:string"/>
        <xs:attribute name="parserFactoryRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="grokDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string" use="required"/>
        <xs:attribute name="flattened" type="xs:string"/>
        <xs:attribute name="allowMultipleMatchesPerLine" type="xs:string"/>
        <xs:attribute name="namedOnly" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="gzipDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="hl7DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="validate" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="icalDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="validating" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jacksonXMLDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="xmlMapper" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:string"/>
        <xs:attribute name="unmarshalTypeName" type="xs:string"/>
        <xs:attribute name="jsonView" type="xs:string"/>
        <xs:attribute name="include" type="xs:string"/>
        <xs:attribute name="allowJmsType" type="xs:string"/>
        <xs:attribute name="collectionTypeName" type="xs:string"/>
        <xs:attribute name="useList" type="xs:string"/>
        <xs:attribute name="enableJaxbAnnotationModule" type="xs:string"/>
        <xs:attribute name="moduleClassNames" type="xs:string"/>
        <xs:attribute name="moduleRefs" type="xs:string"/>
        <xs:attribute name="enableFeatures" type="xs:string"/>
        <xs:attribute name="disableFeatures" type="xs:string"/>
        <xs:attribute name="allowUnmarshallType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jaxbDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="contextPath" type="xs:string" use="required"/>
        <xs:attribute name="schema" type="xs:string"/>
        <xs:attribute name="schemaSeverityLevel" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:string"/>
        <xs:attribute name="objectFactory" type="xs:string"/>
        <xs:attribute name="ignoreJAXBElement" type="xs:string"/>
        <xs:attribute name="mustBeJAXBElement" type="xs:string"/>
        <xs:attribute name="filterNonXmlChars" type="xs:string"/>
        <xs:attribute name="encoding" type="xs:string"/>
        <xs:attribute name="fragment" type="xs:string"/>
        <xs:attribute name="partClass" type="xs:string"/>
        <xs:attribute name="partNamespace" type="xs:string"/>
        <xs:attribute name="namespacePrefixRef" type="xs:string"/>
        <xs:attribute name="xmlStreamWriterWrapper" type="xs:string"/>
        <xs:attribute name="schemaLocation" type="xs:string"/>
        <xs:attribute name="noNamespaceSchemaLocation" type="xs:string"/>
        <xs:attribute name="jaxbProviderProperties" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jsonDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="objectMapper" type="xs:string"/>
        <xs:attribute name="useDefaultObjectMapper" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:string"/>
        <xs:attribute name="library" type="tns:jsonLibrary"/>
        <xs:attribute name="unmarshalTypeName" type="xs:string"/>
        <xs:attribute name="jsonView" type="xs:string"/>
        <xs:attribute name="include" type="xs:string"/>
        <xs:attribute name="allowJmsType" type="xs:string"/>
        <xs:attribute name="collectionTypeName" type="xs:string"/>
        <xs:attribute name="useList" type="xs:string"/>
        <xs:attribute name="enableJaxbAnnotationModule" type="xs:string"/>
        <xs:attribute name="moduleClassNames" type="xs:string"/>
        <xs:attribute name="moduleRefs" type="xs:string"/>
        <xs:attribute name="enableFeatures" type="xs:string"/>
        <xs:attribute name="disableFeatures" type="xs:string"/>
        <xs:attribute name="permissions" type="xs:string"/>
        <xs:attribute name="allowUnmarshallType" type="xs:string"/>
        <xs:attribute name="timezone" type="xs:string"/>
        <xs:attribute name="autoDiscoverObjectMapper" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jsonApiDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="dataFormatTypes">
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="mainFormatType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="lzfDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="usingParallelCompression" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="mimeMultipartDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="multipartSubType" type="xs:string"/>
        <xs:attribute name="multipartWithoutAttachment" type="xs:string"/>
        <xs:attribute name="headersInline" type="xs:string"/>
        <xs:attribute name="includeHeaders" type="xs:string"/>
        <xs:attribute name="binaryContent" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="protobufDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="instanceClass" type="xs:string"/>
        <xs:attribute name="contentTypeFormat" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="rssDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlSecurityDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="xmlCipherAlgorithm" type="xs:string"/>
        <xs:attribute name="passPhrase" type="xs:string"/>
        <xs:attribute name="passPhraseByte" type="xs:base64Binary"/>
        <xs:attribute name="secureTag" type="xs:string"/>
        <xs:attribute name="secureTagContents" type="xs:string"/>
        <xs:attribute name="keyCipherAlgorithm" type="xs:string"/>
        <xs:attribute name="recipientKeyAlias" type="xs:string"/>
        <xs:attribute name="keyOrTrustStoreParametersRef" type="xs:string"/>
        <xs:attribute name="keyPassword" type="xs:string"/>
        <xs:attribute name="digestAlgorithm" type="xs:string"/>
        <xs:attribute name="mgfAlgorithm" type="xs:string"/>
        <xs:attribute name="addKeyValueForEncryptedKey" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="soapJaxbDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="contextPath" type="xs:string" use="required"/>
        <xs:attribute name="encoding" type="xs:string"/>
        <xs:attribute name="elementNameStrategyRef" type="xs:string"/>
        <xs:attribute name="version" type="xs:string"/>
        <xs:attribute name="namespacePrefixRef" type="xs:string"/>
        <xs:attribute name="schema" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="syslogDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tarFileDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="usingIterator" type="xs:string"/>
        <xs:attribute name="allowEmptyDirectory" type="xs:string"/>
        <xs:attribute name="preservePathElements" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="thriftDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="instanceClass" type="xs:string"/>
        <xs:attribute name="contentTypeFormat" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tidyMarkupDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="dataObjectType" type="xs:string"/>
        <xs:attribute name="omitXmlDeclaration" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="uniVocityCsvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:uniVocityAbstractDataFormat">
        <xs:sequence/>
        <xs:attribute name="quoteAllFields" type="xs:string"/>
        <xs:attribute name="quote" type="xs:string"/>
        <xs:attribute name="quoteEscape" type="xs:string"/>
        <xs:attribute name="delimiter" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="uniVocityAbstractDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:univocity-header"/>
        </xs:sequence>
        <xs:attribute name="nullValue" type="xs:string"/>
        <xs:attribute name="skipEmptyLines" type="xs:string"/>
        <xs:attribute name="ignoreTrailingWhitespaces" type="xs:string"/>
        <xs:attribute name="ignoreLeadingWhitespaces" type="xs:string"/>
        <xs:attribute name="headersDisabled" type="xs:string"/>
        <xs:attribute name="headerExtractionEnabled" type="xs:string"/>
        <xs:attribute name="numberOfRecordsToRead" type="xs:string"/>
        <xs:attribute name="emptyValue" type="xs:string"/>
        <xs:attribute name="lineSeparator" type="xs:string"/>
        <xs:attribute name="normalizedLineSeparator" type="xs:string"/>
        <xs:attribute name="comment" type="xs:string"/>
        <xs:attribute name="lazyLoad" type="xs:string"/>
        <xs:attribute name="asMap" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="uniVocityHeader">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="length" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="uniVocityFixedWidthDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:uniVocityAbstractDataFormat">
        <xs:sequence/>
        <xs:attribute name="skipTrailingCharsUntilNewline" type="xs:string"/>
        <xs:attribute name="recordEndsOnNewline" type="xs:string"/>
        <xs:attribute name="padding" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="uniVocityTsvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:uniVocityAbstractDataFormat">
        <xs:sequence/>
        <xs:attribute name="escapeChar" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlRpcDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="request" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xStreamDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element minOccurs="0" name="converters" type="tns:converterList"/>
          <xs:element minOccurs="0" name="aliases" type="tns:aliasList"/>
          <xs:element minOccurs="0" name="omitFields" type="tns:omitFieldList"/>
          <xs:element minOccurs="0" name="implicitCollections" type="tns:implicitCollectionList"/>
        </xs:sequence>
        <xs:attribute name="permissions" type="xs:string"/>
        <xs:attribute name="encoding" type="xs:string"/>
        <xs:attribute name="driver" type="xs:string"/>
        <xs:attribute name="driverRef" type="xs:string"/>
        <xs:attribute name="mode" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="converterList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="converter" type="tns:converterEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="converterEntry">
    <xs:sequence/>
    <xs:attribute name="class" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="aliasList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="alias" type="tns:aliasEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="aliasEntry">
    <xs:sequence/>
    <xs:attribute name="name" type="xs:string"/>
    <xs:attribute name="class" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="omitFieldList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="omitField" type="tns:omitFieldEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="omitFieldEntry">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="field" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="class" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="implicitCollectionList">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="class" type="tns:implicitCollectionEntry"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="implicitCollectionEntry">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="field" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="pgpDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="keyUserid" type="xs:string"/>
        <xs:attribute name="signatureKeyUserid" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="signaturePassword" type="xs:string"/>
        <xs:attribute name="keyFileName" type="xs:string"/>
        <xs:attribute name="signatureKeyFileName" type="xs:string"/>
        <xs:attribute name="signatureKeyRing" type="xs:string"/>
        <xs:attribute name="armored" type="xs:string"/>
        <xs:attribute name="integrity" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="algorithm" type="xs:string"/>
        <xs:attribute name="compressionAlgorithm" type="xs:string"/>
        <xs:attribute name="hashAlgorithm" type="xs:string"/>
        <xs:attribute name="signatureVerificationOption" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="yamlDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:typeFilter"/>
        </xs:sequence>
        <xs:attribute name="library" type="tns:yamlLibrary"/>
        <xs:attribute name="unmarshalTypeName" type="xs:string"/>
        <xs:attribute name="constructor" type="xs:string"/>
        <xs:attribute name="representer" type="xs:string"/>
        <xs:attribute name="dumperOptions" type="xs:string"/>
        <xs:attribute name="resolver" type="xs:string"/>
        <xs:attribute name="useApplicationContextClassLoader" type="xs:string"/>
        <xs:attribute name="prettyFlow" type="xs:string"/>
        <xs:attribute name="allowAnyType" type="xs:string"/>
        <xs:attribute name="maxAliasesForCollections" type="xs:string"/>
        <xs:attribute name="allowRecursiveKeys" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="yamlTypeFilterDefinition">
    <xs:sequence/>
    <xs:attribute name="value" type="xs:string"/>
    <xs:attribute name="type" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="zipDeflaterDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="compressionLevel" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="zipFileDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="usingIterator" type="xs:string"/>
        <xs:attribute name="allowEmptyDirectory" type="xs:string"/>
        <xs:attribute name="preservePathElements" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="multicastDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="parallelProcessing" type="xs:string"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
        <xs:attribute name="strategyMethodAllowNull" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="streaming" type="xs:string"/>
        <xs:attribute name="stopOnException" type="xs:string"/>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="onPrepareRef" type="xs:string"/>
        <xs:attribute name="shareUnitOfWork" type="xs:string"/>
        <xs:attribute name="parallelAggregate" type="xs:string"/>
        <xs:attribute name="stopOnAggregateException" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="onCompletionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="mode" type="xs:string"/>
        <xs:attribute name="onCompleteOnly" type="xs:string"/>
        <xs:attribute name="onFailureOnly" type="xs:string"/>
        <xs:attribute name="parallelProcessing" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="useOriginalMessage" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="onExceptionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" name="exception" type="xs:string"/>
          <xs:element minOccurs="0" name="onWhen" type="tns:whenDefinition"/>
          <xs:element minOccurs="0" name="retryWhile" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" ref="tns:redeliveryPolicy"/>
          <xs:element minOccurs="0" name="handled" type="tns:expressionSubElementDefinition"/>
          <xs:element minOccurs="0" name="continued" type="tns:expressionSubElementDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="redeliveryPolicyRef" type="xs:string"/>
        <xs:attribute name="onRedeliveryRef" type="xs:string"/>
        <xs:attribute name="onExceptionOccurredRef" type="xs:string"/>
        <xs:attribute name="useOriginalMessage" type="xs:string"/>
        <xs:attribute name="useOriginalBody" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="redeliveryPolicyDefinition">
    <xs:sequence/>
    <xs:attribute name="maximumRedeliveries" type="xs:string"/>
    <xs:attribute name="redeliveryDelay" type="xs:string"/>
    <xs:attribute name="asyncDelayedRedelivery" type="xs:string"/>
    <xs:attribute name="backOffMultiplier" type="xs:string"/>
    <xs:attribute name="useExponentialBackOff" type="xs:string"/>
    <xs:attribute name="collisionAvoidanceFactor" type="xs:string"/>
    <xs:attribute name="useCollisionAvoidance" type="xs:string"/>
    <xs:attribute name="maximumRedeliveryDelay" type="xs:string"/>
    <xs:attribute name="retriesExhaustedLogLevel" type="xs:string"/>
    <xs:attribute name="retryAttemptedLogLevel" type="xs:string"/>
    <xs:attribute name="retryAttemptedLogInterval" type="xs:string"/>
    <xs:attribute name="logRetryAttempted" type="xs:string"/>
    <xs:attribute name="logStackTrace" type="xs:string"/>
    <xs:attribute name="logRetryStackTrace" type="xs:string"/>
    <xs:attribute name="logHandled" type="xs:string"/>
    <xs:attribute name="logNewException" type="xs:string"/>
    <xs:attribute name="logContinued" type="xs:string"/>
    <xs:attribute name="logExhausted" type="xs:string"/>
    <xs:attribute name="logExhaustedMessageHistory" type="xs:string"/>
    <xs:attribute name="logExhaustedMessageBody" type="xs:string"/>
    <xs:attribute name="disableRedelivery" type="xs:string"/>
    <xs:attribute name="delayPattern" type="xs:string"/>
    <xs:attribute name="allowRedeliveryWhileStopping" type="xs:string"/>
    <xs:attribute name="exchangeFormatterRef" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="onFallbackDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="fallbackViaNetwork" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="outputTypeDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="urn" type="xs:string"/>
        <xs:attribute name="validate" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="packageScanDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" name="package" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="excludes" type="xs:string"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="includes" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="pipelineDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="policyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="pollEnrichDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
        <xs:attribute name="strategyMethodAllowNull" type="xs:string"/>
        <xs:attribute name="aggregateOnException" type="xs:string"/>
        <xs:attribute name="cacheSize" type="xs:string"/>
        <xs:attribute name="ignoreInvalidEndpoint" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="recipientListDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="delimiter" type="xs:string"/>
        <xs:attribute name="parallelProcessing" type="xs:string"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
        <xs:attribute name="strategyMethodAllowNull" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="stopOnException" type="xs:string"/>
        <xs:attribute name="ignoreInvalidEndpoints" type="xs:string"/>
        <xs:attribute name="streaming" type="xs:string"/>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="onPrepareRef" type="xs:string"/>
        <xs:attribute name="shareUnitOfWork" type="xs:string"/>
        <xs:attribute name="cacheSize" type="xs:string"/>
        <xs:attribute name="parallelAggregate" type="xs:string"/>
        <xs:attribute name="stopOnAggregateException" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removeHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removeHeadersDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string" use="required"/>
        <xs:attribute name="excludePattern" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removePropertiesDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string" use="required"/>
        <xs:attribute name="excludePattern" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removePropertyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="resequenceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:batch-config"/>
            <xs:element ref="tns:stream-config"/>
          </xs:choice>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="batchResequencerConfig">
    <xs:complexContent>
      <xs:extension base="tns:resequencerConfig">
        <xs:sequence/>
        <xs:attribute name="batchSize" type="xs:string"/>
        <xs:attribute name="batchTimeout" type="xs:string"/>
        <xs:attribute name="allowDuplicates" type="xs:string"/>
        <xs:attribute name="reverse" type="xs:string"/>
        <xs:attribute name="ignoreInvalidExchanges" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="resequencerConfig">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="streamResequencerConfig">
    <xs:complexContent>
      <xs:extension base="tns:resequencerConfig">
        <xs:sequence/>
        <xs:attribute name="capacity" type="xs:string"/>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="deliveryAttemptInterval" type="xs:string"/>
        <xs:attribute name="ignoreInvalidExchanges" type="xs:string"/>
        <xs:attribute name="comparatorRef" type="xs:string"/>
        <xs:attribute name="rejectOld" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restContextRefDefinition">
    <xs:sequence/>
    <xs:attribute name="ref" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="rollbackDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="markRollbackOnly" type="xs:string"/>
        <xs:attribute name="markRollbackOnlyLast" type="xs:string"/>
        <xs:attribute name="message" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeBuilderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeContextRefDefinition">
    <xs:sequence/>
    <xs:attribute name="ref" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="routeDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element minOccurs="0" ref="tns:from"/>
          <xs:element minOccurs="0" ref="tns:inputType"/>
          <xs:element minOccurs="0" ref="tns:outputType"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="routeProperty" type="tns:propertyDefinition"/>
        </xs:sequence>
        <xs:attribute name="autoStartup" type="xs:string"/>
        <xs:attribute name="delayer" type="xs:string"/>
        <xs:attribute name="errorHandlerRef" type="xs:string"/>
        <xs:attribute name="group" type="xs:string"/>
        <xs:attribute name="logMask" type="xs:string"/>
        <xs:attribute name="messageHistory" type="xs:string"/>
        <xs:attribute name="rest" type="xs:boolean"/>
        <xs:attribute name="routePolicyRef" type="xs:string"/>
        <xs:attribute name="shutdownRoute" type="xs:string"/>
        <xs:attribute name="shutdownRunningTask" type="xs:string"/>
        <xs:attribute name="startupOrder" type="xs:int"/>
        <xs:attribute name="streamCache" type="xs:string"/>
        <xs:attribute name="trace" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routesDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:route"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routingSlipDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="uriDelimiter" type="xs:string"/>
        <xs:attribute name="ignoreInvalidEndpoints" type="xs:string"/>
        <xs:attribute name="cacheSize" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sagaActionUriDefinition">
    <xs:sequence/>
    <xs:attribute name="uri" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="sagaDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element minOccurs="0" name="compensation" type="tns:sagaActionUriDefinition"/>
          <xs:element minOccurs="0" name="completion" type="tns:sagaActionUriDefinition"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="option" type="tns:sagaOptionDefinition"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="propagation" type="xs:string"/>
        <xs:attribute name="completionMode" type="xs:string"/>
        <xs:attribute name="timeoutInMilliseconds" type="xs:string"/>
        <xs:attribute name="sagaServiceRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sagaOptionDefinition">
    <xs:choice>
      <xs:element ref="tns:expressionDefinition"/>
      <xs:element ref="tns:constant"/>
      <xs:element ref="tns:exchangeProperty"/>
      <xs:element ref="tns:groovy"/>
      <xs:element ref="tns:header"/>
      <xs:element ref="tns:hl7terser"/>
      <xs:element ref="tns:jsonpath"/>
      <xs:element ref="tns:language"/>
      <xs:element ref="tns:method"/>
      <xs:element ref="tns:mvel"/>
      <xs:element ref="tns:ognl"/>
      <xs:element ref="tns:ref"/>
      <xs:element ref="tns:simple"/>
      <xs:element ref="tns:spel"/>
      <xs:element ref="tns:tokenize"/>
      <xs:element ref="tns:xtokenize"/>
      <xs:element ref="tns:xpath"/>
      <xs:element ref="tns:xquery"/>
    </xs:choice>
    <xs:attribute name="optionName" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="samplingDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="samplePeriod" type="xs:string"/>
        <xs:attribute name="messageFrequency" type="xs:string"/>
        <xs:attribute name="units" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="scriptDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setExchangePatternDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="name" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setPropertyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="name" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sortDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
        <xs:attribute name="comparatorRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="splitDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="parallelProcessing" type="xs:string"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="strategyMethodName" type="xs:string"/>
        <xs:attribute name="strategyMethodAllowNull" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="streaming" type="xs:string"/>
        <xs:attribute name="stopOnException" type="xs:string"/>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="onPrepareRef" type="xs:string"/>
        <xs:attribute name="shareUnitOfWork" type="xs:string"/>
        <xs:attribute name="parallelAggregate" type="xs:string"/>
        <xs:attribute name="stopOnAggregateException" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stepDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="threadPoolProfileDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="defaultProfile" type="xs:string"/>
        <xs:attribute name="poolSize" type="xs:string"/>
        <xs:attribute name="maxPoolSize" type="xs:string"/>
        <xs:attribute name="keepAliveTime" type="xs:string"/>
        <xs:attribute name="timeUnit" type="xs:string"/>
        <xs:attribute name="maxQueueSize" type="xs:string"/>
        <xs:attribute name="allowCoreThreadTimeOut" type="xs:string"/>
        <xs:attribute name="rejectedPolicy" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="threadsDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="poolSize" type="xs:string"/>
        <xs:attribute name="maxPoolSize" type="xs:string"/>
        <xs:attribute name="keepAliveTime" type="xs:string"/>
        <xs:attribute name="timeUnit" type="xs:string"/>
        <xs:attribute name="maxQueueSize" type="xs:string"/>
        <xs:attribute name="allowCoreThreadTimeOut" type="xs:string"/>
        <xs:attribute name="threadName" type="xs:string"/>
        <xs:attribute name="rejectedPolicy" type="xs:string"/>
        <xs:attribute name="callerRunsWhenRejected" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throttleDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice>
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:element minOccurs="0" name="correlationExpression" type="tns:expressionSubElementDefinition"/>
        </xs:sequence>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="timePeriodMillis" type="xs:string"/>
        <xs:attribute name="asyncDelayed" type="xs:string"/>
        <xs:attribute name="callerRunsWhenRejected" type="xs:string"/>
        <xs:attribute name="rejectExecution" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throwExceptionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="message" type="xs:string"/>
        <xs:attribute name="exceptionType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="toDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="toDynamicDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="pattern" type="xs:string"/>
        <xs:attribute name="cacheSize" type="xs:string"/>
        <xs:attribute name="ignoreInvalidEndpoint" type="xs:string"/>
        <xs:attribute name="allowOptimisedComponents" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transactedDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transformDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tryDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:circuitBreaker"/>
            <xs:element ref="tns:claimCheck"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:dynamicRouter"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptSendToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:log"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:onFallback"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeHeaders"/>
            <xs:element ref="tns:removeProperties"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:saga"/>
            <xs:element ref="tns:sample"/>
            <xs:element ref="tns:script"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:step"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:validate"/>
            <xs:element ref="tns:whenSkipSendToEndpoint"/>
            <xs:element ref="tns:wireTap"/>
            <xs:element ref="tns:serviceCall"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="unmarshalDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:any23"/>
            <xs:element ref="tns:asn1"/>
            <xs:element ref="tns:avro"/>
            <xs:element ref="tns:barcode"/>
            <xs:element ref="tns:base64"/>
            <xs:element ref="tns:beanio"/>
            <xs:element ref="tns:bindy"/>
            <xs:element ref="tns:cbor"/>
            <xs:element ref="tns:crypto"/>
            <xs:element ref="tns:csv"/>
            <xs:element name="custom" type="tns:customDataFormat"/>
            <xs:element ref="tns:fhirJson"/>
            <xs:element ref="tns:fhirXml"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:grok"/>
            <xs:element name="gzip" type="tns:gzipDataFormat"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:ical"/>
            <xs:element ref="tns:jacksonxml"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:json"/>
            <xs:element ref="tns:jsonApi"/>
            <xs:element ref="tns:lzf"/>
            <xs:element name="mimeMultipart" type="tns:mimeMultipartDataFormat"/>
            <xs:element ref="tns:protobuf"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:soapjaxb"/>
            <xs:element ref="tns:syslog"/>
            <xs:element ref="tns:tarfile"/>
            <xs:element ref="tns:thrift"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:univocity-csv"/>
            <xs:element ref="tns:univocity-fixed"/>
            <xs:element ref="tns:univocity-tsv"/>
            <xs:element ref="tns:xmlrpc"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:pgp"/>
            <xs:element ref="tns:yaml"/>
            <xs:element name="zip" type="tns:zipDeflaterDataFormat"/>
            <xs:element ref="tns:zipfile"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="validateDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="whenSkipSendToEndpointDefinition">
    <xs:complexContent>
      <xs:extension base="tns:whenDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="wireTapDefinition">
    <xs:complexContent>
      <xs:extension base="tns:toDynamicDefinition">
        <xs:sequence>
          <xs:element minOccurs="0" name="body" type="tns:expressionSubElementDefinition"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:setHeader"/>
        </xs:sequence>
        <xs:attribute name="processorRef" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="copy" type="xs:string"/>
        <xs:attribute name="dynamicUri" type="xs:string"/>
        <xs:attribute name="onPrepareRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="blacklistServiceCallServiceFilterConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceFilterConfiguration">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="servers" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceCallServiceFilterConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="serviceCallConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="properties" type="tns:propertyDefinition"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="cachingServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:consulServiceDiscovery"/>
            <xs:element ref="tns:dnsServiceDiscovery"/>
            <xs:element ref="tns:etcdServiceDiscovery"/>
            <xs:element ref="tns:kubernetesServiceDiscovery"/>
            <xs:element ref="tns:combinedServiceDiscovery"/>
            <xs:element ref="tns:staticServiceDiscovery"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="units" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="consulServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence/>
        <xs:attribute name="url" type="xs:string"/>
        <xs:attribute name="datacenter" type="xs:string"/>
        <xs:attribute name="aclToken" type="xs:string"/>
        <xs:attribute name="userName" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="connectTimeoutMillis" type="xs:string"/>
        <xs:attribute name="readTimeoutMillis" type="xs:string"/>
        <xs:attribute name="writeTimeoutMillis" type="xs:string"/>
        <xs:attribute name="blockSeconds" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dnsServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence/>
        <xs:attribute name="proto" type="xs:string"/>
        <xs:attribute name="domain" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="etcdServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence/>
        <xs:attribute name="uris" type="xs:string"/>
        <xs:attribute name="userName" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="timeout" type="xs:string"/>
        <xs:attribute name="servicePath" type="xs:string"/>
        <xs:attribute name="type" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="kubernetesServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence/>
        <xs:attribute name="lookup" type="xs:string"/>
        <xs:attribute name="dnsDomain" type="xs:string"/>
        <xs:attribute name="portName" type="xs:string"/>
        <xs:attribute name="portProtocol" type="xs:string"/>
        <xs:attribute name="namespace" type="xs:string"/>
        <xs:attribute name="apiVersion" type="xs:string"/>
        <xs:attribute name="masterUrl" type="xs:string"/>
        <xs:attribute name="username" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="oauthToken" type="xs:string"/>
        <xs:attribute name="caCertData" type="xs:string"/>
        <xs:attribute name="caCertFile" type="xs:string"/>
        <xs:attribute name="clientCertData" type="xs:string"/>
        <xs:attribute name="clientCertFile" type="xs:string"/>
        <xs:attribute name="clientKeyAlgo" type="xs:string"/>
        <xs:attribute name="clientKeyData" type="xs:string"/>
        <xs:attribute name="clientKeyFile" type="xs:string"/>
        <xs:attribute name="clientKeyPassphrase" type="xs:string"/>
        <xs:attribute name="trustCerts" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="combinedServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:consulServiceDiscovery"/>
            <xs:element ref="tns:dnsServiceDiscovery"/>
            <xs:element ref="tns:etcdServiceDiscovery"/>
            <xs:element ref="tns:kubernetesServiceDiscovery"/>
            <xs:element ref="tns:staticServiceDiscovery"/>
            <xs:element ref="tns:cachingServiceDiscovery"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="staticServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="servers" type="xs:string"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="combinedServiceCallServiceFilterConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceFilterConfiguration">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:blacklistServiceFilter"/>
            <xs:element ref="tns:customServiceFilter"/>
            <xs:element ref="tns:healthyServiceFilter"/>
            <xs:element ref="tns:passThroughServiceFilter"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="customServiceCallServiceFilterConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceFilterConfiguration">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="healthyServiceCallServiceFilterConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceFilterConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="passThroughServiceCallServiceFilterConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceFilterConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="defaultServiceCallServiceLoadBalancerConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceLoadBalancerConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceCallServiceLoadBalancerConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="ribbonServiceCallServiceLoadBalancerConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceLoadBalancerConfiguration">
        <xs:sequence/>
        <xs:attribute name="namespace" type="xs:string"/>
        <xs:attribute name="username" type="xs:string"/>
        <xs:attribute name="password" type="xs:string"/>
        <xs:attribute name="clientName" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceCallConfigurationDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:cachingServiceDiscovery"/>
            <xs:element ref="tns:combinedServiceDiscovery"/>
            <xs:element ref="tns:consulServiceDiscovery"/>
            <xs:element ref="tns:dnsServiceDiscovery"/>
            <xs:element ref="tns:etcdServiceDiscovery"/>
            <xs:element ref="tns:kubernetesServiceDiscovery"/>
            <xs:element ref="tns:staticServiceDiscovery"/>
            <xs:element ref="tns:zookeeperServiceDiscovery"/>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:blacklistServiceFilter"/>
            <xs:element ref="tns:combinedServiceFilter"/>
            <xs:element ref="tns:customServiceFilter"/>
            <xs:element ref="tns:healthyServiceFilter"/>
            <xs:element ref="tns:passThroughServiceFilter"/>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:ribbonLoadBalancer"/>
            <xs:element ref="tns:defaultLoadBalancer"/>
          </xs:choice>
          <xs:element minOccurs="0" name="expression" type="tns:serviceCallExpressionConfiguration"/>
        </xs:sequence>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="component" type="xs:string"/>
        <xs:attribute name="pattern" type="xs:string"/>
        <xs:attribute name="serviceDiscoveryRef" type="xs:string"/>
        <xs:attribute name="serviceFilterRef" type="xs:string"/>
        <xs:attribute name="serviceChooserRef" type="xs:string"/>
        <xs:attribute name="loadBalancerRef" type="xs:string"/>
        <xs:attribute name="expressionRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="zooKeeperServiceCallServiceDiscoveryConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallServiceDiscoveryConfiguration">
        <xs:sequence/>
        <xs:attribute name="nodes" type="xs:string" use="required"/>
        <xs:attribute name="namespace" type="xs:string"/>
        <xs:attribute name="reconnectBaseSleepTime" type="xs:string"/>
        <xs:attribute name="reconnectMaxSleepTime" type="xs:string"/>
        <xs:attribute name="reconnectMaxRetries" type="xs:string"/>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
        <xs:attribute name="connectionTimeout" type="xs:string"/>
        <xs:attribute name="basePath" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceCallExpressionConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallConfiguration">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:exchangeProperty"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:hl7terser"/>
            <xs:element ref="tns:jsonpath"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:ref"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:spel"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xtokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="hostHeader" type="xs:string"/>
        <xs:attribute name="portHeader" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceCallDefinition">
    <xs:complexContent>
      <xs:extension base="tns:noOutputDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:cachingServiceDiscovery"/>
            <xs:element ref="tns:combinedServiceDiscovery"/>
            <xs:element ref="tns:consulServiceDiscovery"/>
            <xs:element ref="tns:dnsServiceDiscovery"/>
            <xs:element ref="tns:etcdServiceDiscovery"/>
            <xs:element ref="tns:kubernetesServiceDiscovery"/>
            <xs:element ref="tns:staticServiceDiscovery"/>
            <xs:element ref="tns:zookeeperServiceDiscovery"/>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:blacklistServiceFilter"/>
            <xs:element ref="tns:combinedServiceFilter"/>
            <xs:element ref="tns:customServiceFilter"/>
            <xs:element ref="tns:healthyServiceFilter"/>
            <xs:element ref="tns:passThroughServiceFilter"/>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:ribbonLoadBalancer"/>
            <xs:element ref="tns:defaultLoadBalancer"/>
          </xs:choice>
          <xs:element minOccurs="0" name="expressionConfiguration" type="tns:serviceCallExpressionConfiguration"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="component" type="xs:string"/>
        <xs:attribute name="pattern" type="xs:string"/>
        <xs:attribute name="configurationRef" type="xs:string"/>
        <xs:attribute name="serviceDiscoveryRef" type="xs:string"/>
        <xs:attribute name="serviceFilterRef" type="xs:string"/>
        <xs:attribute name="serviceChooserRef" type="xs:string"/>
        <xs:attribute name="loadBalancerRef" type="xs:string"/>
        <xs:attribute name="expressionRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="serviceCallDefinitionConstants">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="serviceCallServiceChooserConfiguration">
    <xs:complexContent>
      <xs:extension base="tns:serviceCallConfiguration">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormatsDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element ref="tns:any23"/>
        <xs:element ref="tns:asn1"/>
        <xs:element ref="tns:avro"/>
        <xs:element ref="tns:barcode"/>
        <xs:element ref="tns:base64"/>
        <xs:element ref="tns:beanio"/>
        <xs:element ref="tns:bindy"/>
        <xs:element ref="tns:cbor"/>
        <xs:element ref="tns:crypto"/>
        <xs:element ref="tns:csv"/>
        <xs:element name="custom" type="tns:customDataFormat"/>
        <xs:element ref="tns:fhirJson"/>
        <xs:element ref="tns:fhirXml"/>
        <xs:element ref="tns:flatpack"/>
        <xs:element ref="tns:grok"/>
        <xs:element name="gzip" type="tns:gzipDataFormat"/>
        <xs:element ref="tns:hl7"/>
        <xs:element ref="tns:ical"/>
        <xs:element ref="tns:jacksonxml"/>
        <xs:element ref="tns:jaxb"/>
        <xs:element ref="tns:json"/>
        <xs:element ref="tns:jsonApi"/>
        <xs:element ref="tns:lzf"/>
        <xs:element name="mimeMultipart" type="tns:mimeMultipartDataFormat"/>
        <xs:element ref="tns:protobuf"/>
        <xs:element ref="tns:rss"/>
        <xs:element ref="tns:secureXML"/>
        <xs:element ref="tns:soapjaxb"/>
        <xs:element ref="tns:syslog"/>
        <xs:element ref="tns:tarfile"/>
        <xs:element ref="tns:thrift"/>
        <xs:element ref="tns:tidyMarkup"/>
        <xs:element ref="tns:univocity-csv"/>
        <xs:element ref="tns:univocity-fixed"/>
        <xs:element ref="tns:univocity-tsv"/>
        <xs:element ref="tns:xmlrpc"/>
        <xs:element ref="tns:xstream"/>
        <xs:element ref="tns:pgp"/>
        <xs:element ref="tns:yaml"/>
        <xs:element name="zip" type="tns:zipDeflaterDataFormat"/>
        <xs:element ref="tns:zipfile"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="constantExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="exchangePropertyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="groovyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="headerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="hl7TerserExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="jsonPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="resultType" type="xs:string"/>
        <xs:attribute name="suppressExceptions" type="xs:string"/>
        <xs:attribute name="allowSimple" type="xs:string"/>
        <xs:attribute name="allowEasyPredicate" type="xs:string"/>
        <xs:attribute name="writeAsString" type="xs:string"/>
        <xs:attribute name="headerName" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="languageExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="language" type="xs:string" use="required"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="methodCallExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="method" type="xs:string"/>
        <xs:attribute name="beanType" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="mvelExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="namespaceAwareExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ognlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="refExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="simpleExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="resultType" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="spELExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="tokenizerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="token" type="xs:string" use="required"/>
        <xs:attribute name="endToken" type="xs:string"/>
        <xs:attribute name="inheritNamespaceTagName" type="xs:string"/>
        <xs:attribute name="headerName" type="xs:string"/>
        <xs:attribute name="regex" type="xs:string"/>
        <xs:attribute name="xml" type="xs:string"/>
        <xs:attribute name="includeTokens" type="xs:string"/>
        <xs:attribute name="group" type="xs:string"/>
        <xs:attribute name="groupDelimiter" type="xs:string"/>
        <xs:attribute name="skipFirst" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xmlTokenizerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="headerName" type="xs:string"/>
        <xs:attribute name="mode" type="xs:string"/>
        <xs:attribute name="group" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="documentType" type="xs:string"/>
        <xs:attribute name="resultType" type="xs:string"/>
        <xs:attribute name="saxon" type="xs:string"/>
        <xs:attribute name="factoryRef" type="xs:string"/>
        <xs:attribute name="objectModel" type="xs:string"/>
        <xs:attribute name="logNamespaces" type="xs:string"/>
        <xs:attribute name="headerName" type="xs:string"/>
        <xs:attribute name="threadSafety" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xQueryExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="headerName" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="deleteVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="verbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:param"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:responseMessage"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:security"/>
          <xs:choice>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:toD"/>
            <xs:element ref="tns:route"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="method" type="xs:string"/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="consumes" type="xs:string"/>
        <xs:attribute name="produces" type="xs:string"/>
        <xs:attribute name="bindingMode" type="xs:string"/>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:string"/>
        <xs:attribute name="clientRequestValidation" type="xs:string"/>
        <xs:attribute name="enableCORS" type="xs:string"/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="outType" type="xs:string"/>
        <xs:attribute name="routeId" type="xs:string"/>
        <xs:attribute name="apiDocs" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restOperationParamDefinition">
    <xs:sequence>
      <xs:element minOccurs="0" name="allowableValues">
        <xs:complexType>
          <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" name="value" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="examples" type="tns:restPropertyDefinition"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute name="type" type="tns:restParamType" use="required"/>
    <xs:attribute name="description" type="xs:string"/>
    <xs:attribute name="defaultValue" type="xs:string"/>
    <xs:attribute name="required" type="xs:boolean"/>
    <xs:attribute name="collectionFormat" type="tns:collectionFormat"/>
    <xs:attribute name="arrayType" type="xs:string"/>
    <xs:attribute name="dataType" type="xs:string"/>
    <xs:attribute name="dataFormat" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="restPropertyDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required"/>
    <xs:attribute name="value" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="restOperationResponseMsgDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="header" type="tns:restOperationResponseHeaderDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="examples" type="tns:restPropertyDefinition"/>
    </xs:sequence>
    <xs:attribute name="code" type="xs:string"/>
    <xs:attribute name="message" type="xs:string" use="required"/>
    <xs:attribute name="responseModel" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="restOperationResponseHeaderDefinition">
    <xs:sequence>
      <xs:element minOccurs="0" name="allowableValues">
        <xs:complexType>
          <xs:sequence>
            <xs:element maxOccurs="unbounded" minOccurs="0" name="value" type="xs:string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute name="description" type="xs:string"/>
    <xs:attribute name="collectionFormat" type="tns:collectionFormat"/>
    <xs:attribute name="arrayType" type="xs:string"/>
    <xs:attribute name="dataType" type="xs:string"/>
    <xs:attribute name="dataFormat" type="xs:string"/>
    <xs:attribute name="example" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="securityDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required"/>
    <xs:attribute name="scopes" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="getVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="headVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="patchVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="postVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="putVerbDefinition">
    <xs:complexContent>
      <xs:extension base="tns:verbDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restBindingDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="consumes" type="xs:string"/>
        <xs:attribute name="produces" type="xs:string"/>
        <xs:attribute name="bindingMode" type="xs:string"/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="outType" type="xs:string"/>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:string"/>
        <xs:attribute name="clientRequestValidation" type="xs:string"/>
        <xs:attribute name="enableCORS" type="xs:string"/>
        <xs:attribute name="component" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restConfigurationDefinition">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="componentProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="endpointProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="consumerProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="dataFormatProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="apiProperty" type="tns:restPropertyDefinition"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="corsHeaders" type="tns:restPropertyDefinition"/>
    </xs:sequence>
    <xs:attribute name="component" type="xs:string"/>
    <xs:attribute name="apiComponent" type="xs:string"/>
    <xs:attribute name="producerComponent" type="xs:string"/>
    <xs:attribute name="scheme" type="xs:string"/>
    <xs:attribute name="host" type="xs:string"/>
    <xs:attribute name="apiHost" type="xs:string"/>
    <xs:attribute name="useXForwardHeaders" type="xs:boolean"/>
    <xs:attribute name="port" type="xs:string"/>
    <xs:attribute name="producerApiDoc" type="xs:string"/>
    <xs:attribute name="contextPath" type="xs:string"/>
    <xs:attribute name="apiContextPath" type="xs:string"/>
    <xs:attribute name="apiContextRouteId" type="xs:string"/>
    <xs:attribute name="apiContextIdPattern" type="xs:string"/>
    <xs:attribute name="apiContextListing" type="xs:boolean"/>
    <xs:attribute name="apiVendorExtension" type="xs:boolean"/>
    <xs:attribute name="hostNameResolver" type="tns:restHostNameResolver"/>
    <xs:attribute name="bindingMode" type="tns:restBindingMode"/>
    <xs:attribute name="skipBindingOnErrorCode" type="xs:boolean"/>
    <xs:attribute name="clientRequestValidation" type="xs:boolean"/>
    <xs:attribute name="enableCORS" type="xs:boolean"/>
    <xs:attribute name="jsonDataFormat" type="xs:string"/>
    <xs:attribute name="xmlDataFormat" type="xs:string"/>
  </xs:complexType>

  <xs:complexType final="extension restriction" name="restConstants">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="restDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element minOccurs="0" ref="tns:securityDefinitions"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:verb"/>
            <xs:element ref="tns:delete"/>
            <xs:element ref="tns:get"/>
            <xs:element ref="tns:head"/>
            <xs:element ref="tns:patch"/>
            <xs:element ref="tns:post"/>
            <xs:element ref="tns:put"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="path" type="xs:string"/>
        <xs:attribute name="tag" type="xs:string"/>
        <xs:attribute name="consumes" type="xs:string"/>
        <xs:attribute name="produces" type="xs:string"/>
        <xs:attribute name="bindingMode" type="xs:string"/>
        <xs:attribute name="skipBindingOnErrorCode" type="xs:string"/>
        <xs:attribute name="clientRequestValidation" type="xs:string"/>
        <xs:attribute name="enableCORS" type="xs:string"/>
        <xs:attribute name="apiDocs" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restSecuritiesDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element ref="tns:apiKey"/>
        <xs:element ref="tns:basicAuth"/>
        <xs:element ref="tns:oauth2"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="restSecurityApiKey">
    <xs:complexContent>
      <xs:extension base="tns:restSecurityDefinition">
        <xs:sequence/>
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attribute name="inHeader" type="xs:string"/>
        <xs:attribute name="inQuery" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="restSecurityDefinition">
    <xs:sequence/>
    <xs:attribute name="key" type="xs:string" use="required"/>
    <xs:attribute name="description" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="restSecurityBasicAuth">
    <xs:complexContent>
      <xs:extension base="tns:restSecurityDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restSecurityOAuth2">
    <xs:complexContent>
      <xs:extension base="tns:restSecurityDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="scopes" type="tns:restPropertyDefinition"/>
        </xs:sequence>
        <xs:attribute name="authorizationUrl" type="xs:string"/>
        <xs:attribute name="tokenUrl" type="xs:string"/>
        <xs:attribute name="flow" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="restsDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:rest"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="customTransformer">
    <xs:complexContent>
      <xs:extension base="tns:transformer">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="className" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="transformer">
    <xs:sequence/>
    <xs:attribute name="scheme" type="xs:string"/>
    <xs:attribute name="fromType" type="xs:string"/>
    <xs:attribute name="toType" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="dataFormatTransformer">
    <xs:complexContent>
      <xs:extension base="tns:transformer">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:any23"/>
            <xs:element ref="tns:asn1"/>
            <xs:element ref="tns:avro"/>
            <xs:element ref="tns:barcode"/>
            <xs:element ref="tns:base64"/>
            <xs:element ref="tns:beanio"/>
            <xs:element ref="tns:bindy"/>
            <xs:element ref="tns:cbor"/>
            <xs:element ref="tns:crypto"/>
            <xs:element ref="tns:csv"/>
            <xs:element name="custom" type="tns:customDataFormat"/>
            <xs:element ref="tns:fhirJson"/>
            <xs:element ref="tns:fhirXml"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:grok"/>
            <xs:element name="gzip" type="tns:gzipDataFormat"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:ical"/>
            <xs:element ref="tns:jacksonxml"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:json"/>
            <xs:element ref="tns:jsonApi"/>
            <xs:element ref="tns:lzf"/>
            <xs:element name="mimeMultipart" type="tns:mimeMultipartDataFormat"/>
            <xs:element ref="tns:protobuf"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:soapjaxb"/>
            <xs:element ref="tns:syslog"/>
            <xs:element ref="tns:tarfile"/>
            <xs:element ref="tns:thrift"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:univocity-csv"/>
            <xs:element ref="tns:univocity-fixed"/>
            <xs:element ref="tns:univocity-tsv"/>
            <xs:element ref="tns:xmlrpc"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:pgp"/>
            <xs:element ref="tns:yaml"/>
            <xs:element name="zip" type="tns:zipDeflaterDataFormat"/>
            <xs:element ref="tns:zipfile"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="endpointTransformer">
    <xs:complexContent>
      <xs:extension base="tns:transformer">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transformersDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element name="dataFormatTransformer" type="tns:dataFormatTransformer"/>
        <xs:element name="endpointTransformer" type="tns:endpointTransformer"/>
        <xs:element name="customTransformer" type="tns:customTransformer"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="customValidator">
    <xs:complexContent>
      <xs:extension base="tns:validator">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="className" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType abstract="true" name="validator">
    <xs:sequence/>
    <xs:attribute name="type" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="endpointValidator">
    <xs:complexContent>
      <xs:extension base="tns:validator">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="predicateValidator">
    <xs:complexContent>
      <xs:extension base="tns:validator">
        <xs:choice>
          <xs:element ref="tns:expressionDefinition"/>
          <xs:element ref="tns:constant"/>
          <xs:element ref="tns:exchangeProperty"/>
          <xs:element ref="tns:groovy"/>
          <xs:element ref="tns:header"/>
          <xs:element ref="tns:hl7terser"/>
          <xs:element ref="tns:jsonpath"/>
          <xs:element ref="tns:language"/>
          <xs:element ref="tns:method"/>
          <xs:element ref="tns:mvel"/>
          <xs:element ref="tns:ognl"/>
          <xs:element ref="tns:ref"/>
          <xs:element ref="tns:simple"/>
          <xs:element ref="tns:spel"/>
          <xs:element ref="tns:tokenize"/>
          <xs:element ref="tns:xtokenize"/>
          <xs:element ref="tns:xpath"/>
          <xs:element ref="tns:xquery"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="validatorsDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element name="endpointValidator" type="tns:endpointValidator"/>
        <xs:element name="predicateValidator" type="tns:predicateValidator"/>
        <xs:element name="customValidator" type="tns:customValidator"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="camelBeanPostProcessor">
    <xs:sequence/>
  </xs:complexType>

  <xs:complexType name="camelConsumerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelConsumerTemplateFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelContextFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" ref="tns:globalOptions"/>
          <xs:element minOccurs="0" ref="tns:propertyPlaceholder"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="package" type="xs:string"/>
          <xs:element minOccurs="0" ref="tns:packageScan"/>
          <xs:element minOccurs="0" ref="tns:contextScan"/>
          <xs:element minOccurs="0" ref="tns:streamCaching"/>
          <xs:element minOccurs="0" ref="tns:jmxAgent"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:template"/>
            <xs:element ref="tns:fluentTemplate"/>
            <xs:element ref="tns:consumerTemplate"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:proxy"/>
            <xs:element ref="tns:export"/>
            <xs:element ref="tns:errorHandler"/>
          </xs:choice>
          <xs:element minOccurs="0" name="defaultServiceCallConfiguration" type="tns:serviceCallConfigurationDefinition"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:serviceCallConfiguration"/>
          <xs:element minOccurs="0" name="defaultHystrixConfiguration" type="tns:hystrixConfigurationDefinition"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:hystrixConfiguration"/>
          <xs:element minOccurs="0" name="defaultResilience4jConfiguration" type="tns:resilience4JConfigurationDefinition"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:resilience4jConfiguration"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:routeBuilder"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:routeContextRef"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:restContextRef"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:threadPoolProfile"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:threadPool"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:endpoint"/>
          <xs:element minOccurs="0" ref="tns:dataFormats"/>
          <xs:element minOccurs="0" ref="tns:transformers"/>
          <xs:element minOccurs="0" ref="tns:validators"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:redeliveryPolicyProfile"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:onException"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:onCompletion"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:intercept"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:interceptFrom"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:interceptSendToEndpoint"/>
          <xs:element minOccurs="0" ref="tns:restConfiguration"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:rest"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" ref="tns:route"/>
        </xs:sequence>
        <xs:attribute name="depends-on" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
List of other bean id's this CamelContext depends up. Multiple bean id's can be
separated by comma.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="trace" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether tracing is enabled or not. To use tracing then this must be enabled
on startup to be installed in the CamelContext.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="backlogTrace" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether backlog tracing is enabled or not. To use backlog tracing then this
must be enabled on startup to be installed in the CamelContext.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="tracePattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Tracing pattern to match which node EIPs to trace. For example to match all To
EIP nodes, use to. The pattern matches by node and route id's Multiple patterns
can be separated by comma.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="debug" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether debugging is enabled or not. To use debugging then this must be
enabled on startup to be installed in the CamelContext.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="messageHistory" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether message history is enabled or not. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logMask" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether security mask for Logging is enabled or not. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logExhaustedMessageBody" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether to log exhausted message body with message history.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streamCache" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether stream caching is enabled or not.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="delayer" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a delay value in millis that a message is delayed at every step it takes in
the route path, slowing the process down to better observe what is occurring.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="errorHandlerRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the name of the error handler object used to default the error handling
strategy.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="autoStartup" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether the object should automatically start when Camel starts. Important:
Currently only routes can be disabled, as CamelContext s are always started.
Note: When setting auto startup false on CamelContext then that takes precedence
and no routes is started. You would need to start CamelContext explicit using
the org.apache.camel.CamelContext#start() method, to start the context, and then
you would need to start the routes manually using
org.apache.camel.spi.RouteController#startRoute(String) . Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shutdownEager" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether to shutdown CamelContext eager when Spring is shutting down. This ensure
a cleaner shutdown of Camel, as dependent bean's are not shutdown at this
moment. The bean's will then be shutdown after camelContext. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useMDCLogging" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Set whether MDC is enabled.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mdcLoggingKeysPattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the pattern used for determine which custom MDC keys to propagate during
message routing when the routing engine continues routing asynchronously for the
given message. Setting this pattern to will propagate all custom keys. Or
setting the pattern to foo,bar will propagate any keys starting with either foo
or bar. Notice that a set of standard Camel MDC keys are always propagated which
starts with camel. as key name. The match rules are applied in this order (case
insensitive): 1. exact match, returns true 2. wildcard match (pattern ends with
a and the name starts with the pattern), returns true 3. regular expression
match, returns true 4. otherwise returns false.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useDataType" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether to enable using data type on Camel messages. Data type are automatic
turned on if: one ore more routes has been explicit configured with input and
output types when using rest-dsl with binding turned on Otherwise data type is
default off.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useBreadcrumb" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Set whether breadcrumb is enabled.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="allowUseOriginalMessage" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether to allow access to the original message from Camel's error handler,
or from org.apache.camel.spi.UnitOfWork#getOriginalInMessage() . Turning this
off can optimize performance, as defensive copy of the original message is not
needed.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="caseInsensitiveHeaders" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether to use case sensitive or insensitive headers. Important: When using case
sensitive (this is set to false). Then the map is case sensitive which means
headers such as content-type and Content-Type are two different keys which can
be a problem for some protocols such as HTTP based, which rely on case
insensitive headers. However case sensitive implementations can yield faster
performance. Therefore use case sensitive implementation with care. Default is
true.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="runtimeEndpointRegistryEnabled" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether org.apache.camel.spi.RuntimeEndpointRegistry is enabled.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="managementNamePattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The naming pattern for creating the CamelContext management name. Default value:
#name#
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="threadNamePattern" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the thread name pattern used for creating the full thread name. The default
pattern is: Camel (#camelId#) thread ##counter# - #name# Where #camelId# is the
name of the org.apache.camel.CamelContext and #counter# is a unique incrementing
counter. and #name# is the regular thread name. You can also use #longName# is
the long thread name which can includes endpoint parameters etc. Default value:
Camel (#camelId#) thread ##counter# - #name#
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shutdownRoute" type="tns:shutdownRoute">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the ShutdownRoute option for routes. Default value: Default
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shutdownRunningTask" type="tns:shutdownRunningTask">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the ShutdownRunningTask option to use when shutting down a route. Default
value: CompleteCurrentTaskOnly
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="loadTypeConverters" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether to load custom type converters by scanning classpath. This can be
turned off if you are only using Camel components that does not provide type
converters which is needed at runtime. In such situations setting this option to
false, can speedup starting Camel. Default value: true
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="typeConverterStatisticsEnabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether or not type converter statistics is enabled. By default the type
converter utilization statistics is disabled. Notice: If enabled then there is a
slight performance impact under very heavy load. You can enable/disable the
statistics at runtime using the
org.apache.camel.spi.TypeConverterRegistry#getStatistics()#setTypeConverterStatisticsEnabled(Boolean)
method, or from JMX on the
org.apache.camel.api.management.mbean.ManagedTypeConverterRegistryMBean mbean.
Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="inflightRepositoryBrowseEnabled" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets whether the inflight repository should allow browsing each inflight
exchange. This is by default disabled as there is a very slight performance
overhead when enabled. Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="typeConverterExists" type="tns:typeConverterExists">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
What should happen when attempting to add a duplicate type converter. The
default behavior is to override the existing. Default value: Override
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="typeConverterExistsLoggingLevel" type="tns:loggingLevel">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The logging level to use when logging that a type converter already exists when
attempting to add a duplicate type converter. The default logging level is WARN.
Default value: WARN
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelProducerTemplateFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelFluentProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelFluentProducerTemplateFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="errorHandlerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element minOccurs="0" name="redeliveryPolicy" type="tns:camelRedeliveryPolicyFactoryBean"/>
        </xs:sequence>
        <xs:attribute name="type" type="tns:errorHandlerType">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The type of the error handler. Default value: DefaultErrorHandler
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deadLetterUri" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
The dead letter endpoint uri for the Dead Letter error handler.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deadLetterHandleNewException" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Whether the dead letter channel should handle (and ignore) any new exception
that may been thrown during sending the message to the dead letter endpoint. The
default value is true which means any such kind of exception is handled and
ignored. Set this to false to let the exception be propagated back on the
org.apache.camel.Exchange . This can be used in situations where you use
transactions, and want to use Camel's dead letter channel to deal with
exceptions during routing, but if the dead letter channel itself fails because
of a new exception being thrown, then by setting this to false the new
exceptions is propagated back and set on the org.apache.camel.Exchange , which
allows the transaction to detect the exception, and rollback.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="level" type="tns:loggingLevel">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Logging level to use when using the logging error handler type. Default value:
ERROR
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="rollbackLoggingLevel" type="tns:loggingLevel">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets the logging level to use for logging transactional rollback. This option is
default WARN. Default value: WARN
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="logName" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Name of the logger to use for the logging error handler.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useOriginalMessage" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Will use the original input org.apache.camel.Message (original body and headers)
when an org.apache.camel.Exchange is moved to the dead letter queue. Notice:
this only applies when all redeliveries attempt have failed and the
org.apache.camel.Exchange is doomed for failure. Instead of using the current
inprogress org.apache.camel.Exchange IN message we use the original IN message
instead. This allows you to store the original input in the dead letter queue
instead of the inprogress snapshot of the IN message. For instance if you route
transform the IN body during routing and then failed. With the original exchange
store in the dead letter queue it might be easier to manually re submit the
org.apache.camel.Exchange again as the IN message is the same as when Camel
received it. So you should be able to send the org.apache.camel.Exchange to the
same input. The difference between useOriginalMessage and useOriginalBody is
that the former includes both the original body and headers, where as the latter
only includes the original body. You can use the latter to enrich the message
with custom headers and include the original message body. The former wont let
you do this, as its using the original message body and headers as they are. You
cannot enable both useOriginalMessage and useOriginalBody. Important: The
original input means the input message that are bounded by the current
org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or
multiple routes if they are connected using internal endpoints such as direct or
seda. When messages is passed via external endpoints such as JMS or HTTP then
the consumer will create a new unit of work, with the message it received as
input as the original input. Also some EIP patterns such as splitter, multicast,
will create a new unit of work boundary for the messages in their sub-route (eg
the splitted message); however these EIPs have an option named shareUnitOfWork
which allows to combine with the parent unit of work in regard to error handling
and therefore use the parent original message. By default this feature is off.
Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="useOriginalBody" type="xs:boolean">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Will use the original input org.apache.camel.Message body (original body only)
when an org.apache.camel.Exchange is moved to the dead letter queue. Notice:
this only applies when all redeliveries attempt have failed and the
org.apache.camel.Exchange is doomed for failure. Instead of using the current
inprogress org.apache.camel.Exchange IN message we use the original IN message
instead. This allows you to store the original input in the dead letter queue
instead of the inprogress snapshot of the IN message. For instance if you route
transform the IN body during routing and then failed. With the original exchange
store in the dead letter queue it might be easier to manually re submit the
org.apache.camel.Exchange again as the IN message is the same as when Camel
received it. So you should be able to send the org.apache.camel.Exchange to the
same input. The difference between useOriginalMessage and useOriginalBody is
that the former includes both the original body and headers, where as the latter
only includes the original body. You can use the latter to enrich the message
with custom headers and include the original message body. The former wont let
you do this, as its using the original message body and headers as they are. You
cannot enable both useOriginalMessage and useOriginalBody. Important: The
original input means the input message that are bounded by the current
org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or
multiple routes if they are connected using internal endpoints such as direct or
seda. When messages is passed via external endpoints such as JMS or HTTP then
the consumer will create a new unit of work, with the message it received as
input as the original input. Also some EIP patterns such as splitter, multicast,
will create a new unit of work boundary for the messages in their sub-route (eg
the splitted message); however these EIPs have an option named shareUnitOfWork
which allows to combine with the parent unit of work in regard to error handling
and therefore use the parent original message. By default this feature is off.
Default value: false
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="transactionTemplateRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
References to the org.springframework.transaction.support.TransactionTemplate to
use with the transaction error handler.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="transactionManagerRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
References to the org.springframework.transaction.PlatformTransactionManager to
use with the transaction error handler.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onRedeliveryRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a reference to a processor that should be processed before a redelivery
attempt. Can be used to change the org.apache.camel.Exchange before its being
redelivered.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onExceptionOccurredRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a reference to a processor that should be processed just after an exception
occurred. Can be used to perform custom logging about the occurred exception at
the exact time it happened. Important: Any exception thrown from this processor
will be ignored.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="onPrepareFailureRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a reference to a processor to prepare the org.apache.camel.Exchange before
handled by the failure processor / dead letter channel. This allows for example
to enrich the message before sending to a dead letter queue.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="retryWhileRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a reference to an retry while expression. Will continue retrying until
expression evaluates to false.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="redeliveryPolicyRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a reference to a RedeliveryPolicy to be used for redelivery settings.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executorServiceRef" type="xs:string">
          <xs:annotation>
            <xs:documentation xml:lang="en"><![CDATA[
Sets a reference to a thread pool to be used by the error handler.
            ]]></xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelRedeliveryPolicyFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelRedeliveryPolicyFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelThreadPoolFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelThreadPoolFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelEndpointFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractCamelEndpointFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelRestContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" ref="tns:rest"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelRouteContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" ref="tns:route"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="keyManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractKeyManagersParametersFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" name="keyStore" type="tns:keyStoreParametersFactoryBean"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="keyStoreParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractKeyStoreParametersFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sslContextClientParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:all>
          <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
          <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="sniHostNames" type="tns:sniHostNames"/>
        </xs:all>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sslContextParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:all>
          <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
          <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="keyManagers" type="tns:keyManagersParametersFactoryBean"/>
          <xs:element minOccurs="0" name="trustManagers" type="tns:trustManagersParametersFactoryBean"/>
          <xs:element minOccurs="0" name="secureRandom" type="tns:secureRandomParametersFactoryBean"/>
          <xs:element minOccurs="0" name="clientParameters" type="tns:sslContextClientParametersFactoryBean"/>
          <xs:element minOccurs="0" name="serverParameters" type="tns:sslContextServerParametersFactoryBean"/>
        </xs:all>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
        <xs:attribute name="provider" type="xs:string"/>
        <xs:attribute name="secureSocketProtocol" type="xs:string"/>
        <xs:attribute name="certAlias" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="trustManagersParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractTrustManagersParametersFactoryBean">
        <xs:sequence>
          <xs:element minOccurs="0" name="keyStore" type="tns:keyStoreParametersFactoryBean"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="secureRandomParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractSecureRandomParametersFactoryBean">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sslContextServerParametersFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:abstractJsseUtilFactoryBean">
        <xs:all>
          <xs:element minOccurs="0" name="cipherSuites" type="tns:cipherSuitesParameters"/>
          <xs:element minOccurs="0" name="cipherSuitesFilter" type="tns:filterParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocols" type="tns:secureSocketProtocolsParameters"/>
          <xs:element minOccurs="0" name="secureSocketProtocolsFilter" type="tns:filterParameters"/>
        </xs:all>
        <xs:attribute name="sessionTimeout" type="xs:string"/>
        <xs:attribute name="clientAuthentication" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="exchangePattern">
    <xs:restriction base="xs:string">
      <xs:enumeration value="InOnly"/>
      <xs:enumeration value="InOut"/>
      <xs:enumeration value="InOptionalOut"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="loggingLevel">
    <xs:restriction base="xs:string">
      <xs:enumeration value="TRACE"/>
      <xs:enumeration value="DEBUG"/>
      <xs:enumeration value="INFO"/>
      <xs:enumeration value="WARN"/>
      <xs:enumeration value="ERROR"/>
      <xs:enumeration value="OFF"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="managementStatisticsLevel">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Extended"/>
      <xs:enumeration value="Default"/>
      <xs:enumeration value="RoutesOnly"/>
      <xs:enumeration value="Off"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdownRoute">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Default"/>
      <xs:enumeration value="Defer"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdownRunningTask">
    <xs:restriction base="xs:string">
      <xs:enumeration value="CompleteCurrentTaskOnly"/>
      <xs:enumeration value="CompleteAllTasks"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="waitForTaskToComplete">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Never"/>
      <xs:enumeration value="IfReplyExpected"/>
      <xs:enumeration value="Always"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="threadPoolRejectedPolicy">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Abort"/>
      <xs:enumeration value="CallerRuns"/>
      <xs:enumeration value="DiscardOldest"/>
      <xs:enumeration value="Discard"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="claimCheckOperation">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Get"/>
      <xs:enumeration value="GetAndRemove"/>
      <xs:enumeration value="Set"/>
      <xs:enumeration value="Push"/>
      <xs:enumeration value="Pop"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="jsonLibrary">
    <xs:restriction base="xs:string">
      <xs:enumeration value="XStream"/>
      <xs:enumeration value="Jackson"/>
      <xs:enumeration value="Johnzon"/>
      <xs:enumeration value="Gson"/>
      <xs:enumeration value="Fastjson"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="yamlLibrary">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SnakeYAML"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="onCompletionMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AfterConsumer"/>
      <xs:enumeration value="BeforeConsumer"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="sagaCompletionMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="AUTO"/>
      <xs:enumeration value="MANUAL"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="sagaPropagation">
    <xs:restriction base="xs:string">
      <xs:enumeration value="REQUIRED"/>
      <xs:enumeration value="REQUIRES_NEW"/>
      <xs:enumeration value="MANDATORY"/>
      <xs:enumeration value="SUPPORTS"/>
      <xs:enumeration value="NOT_SUPPORTED"/>
      <xs:enumeration value="NEVER"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="any23Type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NTRIPLES"/>
      <xs:enumeration value="TURTLE"/>
      <xs:enumeration value="NQUADS"/>
      <xs:enumeration value="RDFXML"/>
      <xs:enumeration value="JSONLD"/>
      <xs:enumeration value="RDFJSON"/>
      <xs:enumeration value="RDF4JMODEL"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="bindyType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Csv"/>
      <xs:enumeration value="Fixed"/>
      <xs:enumeration value="KeyValue"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="yamlTypeFilterType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="type"/>
      <xs:enumeration value="regexp"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="collectionFormat">
    <xs:restriction base="xs:string">
      <xs:enumeration value="csv"/>
      <xs:enumeration value="ssv"/>
      <xs:enumeration value="tsv"/>
      <xs:enumeration value="pipes"/>
      <xs:enumeration value="multi"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="restParamType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="body"/>
      <xs:enumeration value="formData"/>
      <xs:enumeration value="header"/>
      <xs:enumeration value="path"/>
      <xs:enumeration value="query"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="restBindingMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="auto"/>
      <xs:enumeration value="off"/>
      <xs:enumeration value="json"/>
      <xs:enumeration value="xml"/>
      <xs:enumeration value="json_xml"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="restHostNameResolver">
    <xs:restriction base="xs:string">
      <xs:enumeration value="allLocalIp"/>
      <xs:enumeration value="localIp"/>
      <xs:enumeration value="localHostName"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="typeConverterExists">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Override"/>
      <xs:enumeration value="Ignore"/>
      <xs:enumeration value="Fail"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="errorHandlerType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DefaultErrorHandler"/>
      <xs:enumeration value="DeadLetterChannel"/>
      <xs:enumeration value="NoErrorHandler"/>
      <xs:enumeration value="TransactionErrorHandler"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
