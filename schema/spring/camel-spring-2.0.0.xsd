<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema elementFormDefault="qualified" version="1.0" targetNamespace="http://camel.apache.org/schema/spring" xmlns:tns="http://camel.apache.org/schema/spring" xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:element name="aggregate" type="tns:aggregateDefinition"/>

  <xs:element name="aop" type="tns:aopDefinition"/>

  <xs:element name="artixDS" type="tns:artixDSDataFormat"/>

  <xs:element name="batchResequencerConfig" type="tns:batchResequencerConfig"/>

  <xs:element name="bean" type="tns:beanDefinition"/>

  <xs:element name="beanPostProcessor" type="tns:camelBeanPostProcessor"/>

  <xs:element name="bindy" type="tns:bindyDataFormat"/>

  <xs:element name="camelContext" type="tns:camelContextFactoryBean"/>

  <xs:element name="choice" type="tns:choiceDefinition"/>

  <xs:element name="constant" type="tns:constantExpression"/>

  <xs:element name="consumerTemplate" type="tns:camelConsumerTemplateFactoryBean"/>

  <xs:element name="convertBodyTo" type="tns:convertBodyDefinition"/>

  <xs:element name="csv" type="tns:csvDataFormat"/>

  <xs:element name="dataFormats" type="tns:dataFormatsDefinition"/>

  <xs:element name="delay" type="tns:delayDefinition"/>

  <xs:element name="description" type="tns:descriptionDefinition"/>

  <xs:element name="doCatch" type="tns:catchDefinition"/>

  <xs:element name="doFinally" type="tns:finallyDefinition"/>

  <xs:element name="doTry" type="tns:tryDefinition"/>

  <xs:element name="el" type="tns:elExpression"/>

  <xs:element name="endpoint" type="tns:camelEndpointFactoryBean"/>

  <xs:element name="enrich" type="tns:enrichDefinition"/>

  <xs:element name="export" type="tns:camelServiceExporterDefinition"/>

  <xs:element name="expression" type="tns:expressionSubElementDefinition"/>

  <xs:element name="expressionDefinition" type="tns:expression"/>

  <xs:element name="failover" type="tns:failoverLoadBalancerDefinition"/>

  <xs:element name="filter" type="tns:filterDefinition"/>

  <xs:element name="flatpack" type="tns:flatpackDataFormat"/>

  <xs:element name="from" type="tns:fromDefinition"/>

  <xs:element name="groovy" type="tns:groovyExpression"/>

  <xs:element name="gzip" type="tns:gzipDataFormat"/>

  <xs:element name="header" type="tns:headerExpression"/>

  <xs:element name="hl7" type="tns:hl7DataFormat"/>

  <xs:element name="idempotentConsumer" type="tns:idempotentConsumerDefinition"/>

  <xs:element name="inOnly" type="tns:inOnlyDefinition"/>

  <xs:element name="inOut" type="tns:inOutDefinition"/>

  <xs:element name="intercept" type="tns:interceptDefinition"/>

  <xs:element name="interceptFrom" type="tns:interceptFromDefinition"/>

  <xs:element name="interceptToEndpoint" type="tns:interceptSendToEndpointDefinition"/>

  <xs:element name="javaScript" type="tns:javaScriptExpression"/>

  <xs:element name="jaxb" type="tns:jaxbDataFormat"/>

  <xs:element name="jmxAgent" type="tns:camelJMXAgentDefinition"/>

  <xs:element name="json" type="tns:jsonDataFormat"/>

  <xs:element name="jxpath" type="tns:jxPathExpression"/>

  <xs:element name="language" type="tns:languageExpression"/>

  <xs:element name="loadBalance" type="tns:loadBalanceDefinition"/>

  <xs:element name="loop" type="tns:loopDefinition"/>

  <xs:element name="marshal" type="tns:marshalDefinition"/>

  <xs:element name="method" type="tns:methodCallExpression"/>

  <xs:element name="multicast" type="tns:multicastDefinition"/>

  <xs:element name="mvel" type="tns:mvelExpression"/>

  <xs:element name="ognl" type="tns:ognlExpression"/>

  <xs:element name="onCompletion" type="tns:onCompletionDefinition"/>

  <xs:element name="onException" type="tns:onExceptionDefinition"/>

  <xs:element name="otherwise" type="tns:otherwiseDefinition"/>

  <xs:element name="packageScan" type="tns:packageScanDefinition"/>

  <xs:element name="php" type="tns:phpExpression"/>

  <xs:element name="pipeline" type="tns:pipelineDefinition"/>

  <xs:element name="policy" type="tns:policyDefinition"/>

  <xs:element name="pollEnrich" type="tns:pollEnrichDefinition"/>

  <xs:element name="process" type="tns:processDefinition"/>

  <xs:element name="properties" type="tns:propertiesDefinition"/>

  <xs:element name="property" nillable="true" type="xs:anyType"/>

  <xs:element name="proxy" type="tns:camelProxyFactoryDefinition"/>

  <xs:element name="python" type="tns:pythonExpression"/>

  <xs:element name="random" type="tns:randomLoadBalancerDefinition"/>

  <xs:element name="recipientList" type="tns:recipientListDefinition"/>

  <xs:element name="redeliveryPolicy" type="tns:redeliveryPolicyDefinition"/>

  <xs:element name="removeHeader" type="tns:removeHeaderDefinition"/>

  <xs:element name="removeProperty" type="tns:removePropertyDefinition"/>

  <xs:element name="resequence" type="tns:resequenceDefinition"/>

  <xs:element name="rollback" type="tns:rollbackDefinition"/>

  <xs:element name="roundRobin" type="tns:roundRobinLoadBalancerDefinition"/>

  <xs:element name="route" type="tns:routeDefinition"/>

  <xs:element name="routeBuilder" type="tns:routeBuilderDefinition"/>

  <xs:element name="routes" type="tns:routesDefinition"/>

  <xs:element name="routingSlip" type="tns:routingSlipDefinition"/>

  <xs:element name="rss" type="tns:rssDataFormat"/>

  <xs:element name="ruby" type="tns:rubyExpression"/>

  <xs:element name="secureXML" type="tns:xmlSecurityDataFormat"/>

  <xs:element name="serialization" type="tns:serializationDataFormat"/>

  <xs:element name="setBody" type="tns:setBodyDefinition"/>

  <xs:element name="setExchangePattern" type="tns:setExchangePatternDefinition"/>

  <xs:element name="setHeader" type="tns:setHeaderDefinition"/>

  <xs:element name="setOutHeader" type="tns:setOutHeaderDefinition"/>

  <xs:element name="setProperty" type="tns:setPropertyDefinition"/>

  <xs:element name="simple" type="tns:simpleExpression"/>

  <xs:element name="sort" type="tns:sortDefinition"/>

  <xs:element name="split" type="tns:splitDefinition"/>

  <xs:element name="sql" type="tns:sqlExpression"/>

  <xs:element name="sticky" type="tns:stickyLoadBalancerDefinition"/>

  <xs:element name="stop" type="tns:stopDefinition"/>

  <xs:element name="streamResequencerConfig" type="tns:streamResequencerConfig"/>

  <xs:element name="string" type="tns:stringDataFormat"/>

  <xs:element name="template" type="tns:camelProducerTemplateFactoryBean"/>

  <xs:element name="threads" type="tns:threadsDefinition"/>

  <xs:element name="throttle" type="tns:throttleDefinition"/>

  <xs:element name="throwException" type="tns:throwExceptionDefinition"/>

  <xs:element name="tidyMarkup" type="tns:tidyMarkupDataFormat"/>

  <xs:element name="to" type="tns:toDefinition"/>

  <xs:element name="tokenize" type="tns:tokenizerExpression"/>

  <xs:element name="topic" type="tns:topicLoadBalancerDefinition"/>

  <xs:element name="transacted" type="tns:transactedDefinition"/>

  <xs:element name="transform" type="tns:transformDefinition"/>

  <xs:element name="unmarshal" type="tns:unmarshalDefinition"/>

  <xs:element name="when" type="tns:whenDefinition"/>

  <xs:element name="wireTap" type="tns:wireTapDefinition"/>

  <xs:element name="xmlBeans" type="tns:xmlBeansDataFormat"/>

  <xs:element name="xpath" type="tns:xPathExpression"/>

  <xs:element name="xquery" type="tns:xQueryExpression"/>

  <xs:element name="xstream" type="tns:xStreamDataFormat"/>

  <xs:element name="zip" type="tns:zipDataFormat"/>

  <xs:complexType name="aopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="beforeUri" type="xs:string"/>
        <xs:attribute name="afterUri" type="xs:string"/>
        <xs:attribute name="afterFinallyUri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="output">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processorDefinition" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="errorHandlerRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="optionalIdentifiedDefinition" abstract="true">
    <xs:sequence>
      <xs:element ref="tns:description" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:ID"/>
  </xs:complexType>

  <xs:complexType name="descriptionDefinition">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="lang" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="aggregateDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
          <xs:element name="completionPredicate" type="tns:expressionSubElementDefinition" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="batchSize" type="xs:int"/>
        <xs:attribute name="outBatchSize" type="xs:int"/>
        <xs:attribute name="batchTimeout" type="xs:long"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="collectionRef" type="xs:string"/>
        <xs:attribute name="groupExchanges" type="xs:boolean"/>
        <xs:attribute name="batchSizeFromConsumer" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="expressionSubElementDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="1" minOccurs="1">
        <xs:element ref="tns:expressionDefinition"/>
        <xs:element ref="tns:constant"/>
        <xs:element ref="tns:el"/>
        <xs:element ref="tns:groovy"/>
        <xs:element ref="tns:header"/>
        <xs:element ref="tns:jxpath"/>
        <xs:element ref="tns:javaScript"/>
        <xs:element ref="tns:language"/>
        <xs:element ref="tns:method"/>
        <xs:element ref="tns:mvel"/>
        <xs:element ref="tns:ognl"/>
        <xs:element ref="tns:php"/>
        <xs:element ref="tns:property"/>
        <xs:element ref="tns:python"/>
        <xs:element ref="tns:ruby"/>
        <xs:element ref="tns:simple"/>
        <xs:element ref="tns:sql"/>
        <xs:element ref="tns:tokenize"/>
        <xs:element ref="tns:xpath"/>
        <xs:element ref="tns:xquery"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="expression">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="id" type="xs:ID"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="beanDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="method" type="xs:string"/>
        <xs:attribute name="beanType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="catchDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element name="exception" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element name="onWhen" type="tns:whenDefinition" minOccurs="0"/>
          <xs:element name="handled" type="tns:expressionSubElementDefinition" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="whenDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="expressionNode">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="1" minOccurs="1">
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:el"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:jxpath"/>
            <xs:element ref="tns:javaScript"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:php"/>
            <xs:element ref="tns:property"/>
            <xs:element ref="tns:python"/>
            <xs:element ref="tns:ruby"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:sql"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="choiceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element ref="tns:when" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:otherwise" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="otherwiseDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="constants" final="extension restriction"/>

  <xs:complexType name="convertBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="charset" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormat">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="identifiedType" abstract="true">
    <xs:attribute name="id" type="xs:ID"/>
  </xs:complexType>

  <xs:complexType name="delayDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="enrichDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string" use="required"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="filterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="finallyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="fromDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="idempotentConsumerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="messageIdRepositoryRef" type="xs:string"/>
        <xs:attribute name="eager" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOnlyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sendDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOutDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptFromDefinition">
    <xs:complexContent>
      <xs:extension base="tns:interceptDefinition">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptSendToEndpointDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string" use="required"/>
        <xs:attribute name="skipSendToOriginalEndpoint" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalanceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:failover"/>
            <xs:element ref="tns:random"/>
            <xs:element ref="tns:roundRobin"/>
            <xs:element ref="tns:sticky"/>
            <xs:element ref="tns:topic"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="failoverLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element name="exception" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalancer">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="randomLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="roundRobinLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stickyLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence>
          <xs:element name="correlationExpression" type="tns:expressionSubElementDefinition" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="topicLoadBalancerDefinition">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancer">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="marshalDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:artixDS"/>
            <xs:element ref="tns:csv"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:serialization"/>
            <xs:element ref="tns:string"/>
            <xs:element ref="tns:xmlBeans"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:zip"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="artixDSDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="elementTypeName" type="xs:string"/>
        <xs:attribute name="format" type="xs:string"/>
        <xs:attribute name="elementType" type="xs:string"/>
        <xs:attribute name="contentType" type="tns:artixDSContentType"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="csvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="flatpackDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="hl7DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="validate" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jaxbDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="contextPath" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
        <xs:attribute name="ignoreJAXBElement" type="xs:boolean"/>
        <xs:attribute name="encoding" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="rssDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlSecurityDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="xmlCipherAlgorithm" type="xs:string"/>
        <xs:attribute name="passPhrase" type="xs:string"/>
        <xs:attribute name="secureTag" type="xs:string"/>
        <xs:attribute name="secureTagContents" type="xs:boolean" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serializationDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stringDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="charset" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlBeansDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xStreamDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="zipDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="compressionLevel" type="xs:int" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="multicastDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="parallelProcessing" type="xs:boolean"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="streaming" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="nodeFactory"/>

  <xs:complexType name="onCompletionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element name="onWhen" type="tns:whenDefinition" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="onCompleteOnly" type="xs:boolean"/>
        <xs:attribute name="onFailureOnly" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="onExceptionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element name="exception" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element name="onWhen" type="tns:whenDefinition" minOccurs="0"/>
          <xs:element name="retryUntil" type="tns:expressionSubElementDefinition" minOccurs="0"/>
          <xs:element ref="tns:redeliveryPolicy" minOccurs="0"/>
          <xs:element name="handled" type="tns:expressionSubElementDefinition" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="onRedeliveryRef" type="xs:string"/>
        <xs:attribute name="useOriginalMessage" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="redeliveryPolicyDefinition">
    <xs:attribute name="ref" type="xs:string"/>
    <xs:attribute name="maximumRedeliveries" type="xs:int"/>
    <xs:attribute name="redeliveryDelay" type="xs:long"/>
    <xs:attribute name="backOffMultiplier" type="xs:double"/>
    <xs:attribute name="useExponentialBackOff" type="xs:boolean"/>
    <xs:attribute name="collisionAvoidanceFactor" type="xs:double"/>
    <xs:attribute name="useCollisionAvoidance" type="xs:boolean"/>
    <xs:attribute name="maximumRedeliveryDelay" type="xs:long"/>
    <xs:attribute name="retriesExhaustedLogLevel" type="tns:loggingLevel"/>
    <xs:attribute name="retryAttemptedLogLevel" type="tns:loggingLevel"/>
    <xs:attribute name="logStackTrace" type="xs:boolean"/>
    <xs:attribute name="disableRedelivery" type="xs:boolean"/>
  </xs:complexType>

  <xs:complexType name="packageScanDefinition">
    <xs:sequence>
      <xs:element name="package" type="xs:string" maxOccurs="unbounded"/>
      <xs:element name="excludes" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
      <xs:element name="includes" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="pipelineDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="policyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="pollEnrichDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string" use="required"/>
        <xs:attribute name="timeout" type="xs:long"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processorDefinitionHelper" final="extension restriction"/>

  <xs:complexType name="recipientListDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="delimiter" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removeHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removePropertyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="resequenceDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:expressionDefinition"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:el"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:jxpath"/>
            <xs:element ref="tns:javaScript"/>
            <xs:element ref="tns:language"/>
            <xs:element ref="tns:method"/>
            <xs:element ref="tns:mvel"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:php"/>
            <xs:element ref="tns:property"/>
            <xs:element ref="tns:python"/>
            <xs:element ref="tns:ruby"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:sql"/>
            <xs:element ref="tns:tokenize"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
          <xs:element name="batch-config" type="tns:batchResequencerConfig" minOccurs="0"/>
          <xs:element name="stream-config" type="tns:streamResequencerConfig" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="batchResequencerConfig">
    <xs:attribute name="batchSize" type="xs:int"/>
    <xs:attribute name="batchTimeout" type="xs:long"/>
  </xs:complexType>

  <xs:complexType name="streamResequencerConfig">
    <xs:attribute name="capacity" type="xs:int"/>
    <xs:attribute name="timeout" type="xs:long"/>
  </xs:complexType>

  <xs:complexType name="rollbackDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
        <xs:attribute name="message" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeBuilderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:element ref="tns:from" maxOccurs="unbounded" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="delayer" type="xs:long"/>
        <xs:attribute name="group" type="xs:string"/>
        <xs:attribute name="handleFault" type="xs:boolean"/>
        <xs:attribute name="streamCache" type="xs:boolean"/>
        <xs:attribute name="trace" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routesDefinition">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedDefinition">
        <xs:sequence>
          <xs:element ref="tns:route" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routingSlipDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string"/>
        <xs:attribute name="uriDelimiter" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setBodyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setExchangePatternDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="pattern" type="tns:exchangePattern" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setOutHeaderDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setPropertyDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sortDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:element ref="tns:expression" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="comparatorRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="splitDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="parallelProcessing" type="xs:boolean"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="streaming" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stopDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="threadsDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="executorServiceRef" type="xs:string"/>
        <xs:attribute name="poolSize" type="xs:int"/>
        <xs:attribute name="waitForTaskToComplete" type="tns:waitForTaskToComplete"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throttleDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aop"/>
            <xs:element ref="tns:aggregate"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:doCatch"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delay"/>
            <xs:element ref="tns:enrich"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:doFinally"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:interceptFrom"/>
            <xs:element ref="tns:interceptToEndpoint"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:onCompletion"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:pollEnrich"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequence"/>
            <xs:element ref="tns:rollback"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:sort"/>
            <xs:element ref="tns:split"/>
            <xs:element ref="tns:stop"/>
            <xs:element ref="tns:threads"/>
            <xs:element ref="tns:throttle"/>
            <xs:element ref="tns:throwException"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transacted"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:doTry"/>
            <xs:element ref="tns:unmarshal"/>
            <xs:element ref="tns:wireTap"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="maximumRequestsPerPeriod" type="xs:long"/>
        <xs:attribute name="timePeriodMillis" type="xs:long" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throwExceptionDefinition">
    <xs:complexContent>
      <xs:extension base="tns:processorDefinition">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="toDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence/>
        <xs:attribute name="pattern" type="tns:exchangePattern"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transactedDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transformDefinition">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tryDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="unmarshalDefinition">
    <xs:complexContent>
      <xs:extension base="tns:output">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:artixDS"/>
            <xs:element ref="tns:csv"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:rss"/>
            <xs:element ref="tns:secureXML"/>
            <xs:element ref="tns:serialization"/>
            <xs:element ref="tns:string"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:xmlBeans"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:zip"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tidyMarkupDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="dataObjectType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="wireTapDefinition">
    <xs:complexContent>
      <xs:extension base="tns:sendDefinition">
        <xs:sequence>
          <xs:element name="body" type="tns:expressionSubElementDefinition" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="processorRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="propertiesDefinition">
    <xs:sequence>
      <xs:element ref="tns:property" maxOccurs="unbounded" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="propertyDefinition">
    <xs:attribute name="key" type="xs:string" use="required"/>
    <xs:attribute name="value" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="bindyDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="type" type="tns:bindyType" use="required"/>
        <xs:attribute name="packages" use="required">
          <xs:simpleType>
            <xs:list itemType="xs:string"/>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormatsDefinition">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element ref="tns:artixDS"/>
        <xs:element ref="tns:bindy"/>
        <xs:element ref="tns:csv"/>
        <xs:element ref="tns:flatpack"/>
        <xs:element ref="tns:gzip"/>
        <xs:element ref="tns:hl7"/>
        <xs:element ref="tns:jaxb"/>
        <xs:element ref="tns:json"/>
        <xs:element ref="tns:rss"/>
        <xs:element ref="tns:secureXML"/>
        <xs:element ref="tns:serialization"/>
        <xs:element ref="tns:string"/>
        <xs:element ref="tns:tidyMarkup"/>
        <xs:element ref="tns:xmlBeans"/>
        <xs:element ref="tns:xstream"/>
        <xs:element ref="tns:zip"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="gzipDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jsonDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormat">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
        <xs:attribute name="library" type="tns:jsonLibrary"/>
        <xs:attribute name="unmarshalTypeName" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="constantExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="elExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="groovyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="headerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="jxPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="javaScriptExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="languageExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="language" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="methodCallExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="bean" type="xs:string"/>
        <xs:attribute name="method" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="mvelExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="namespaceAwareExpression" abstract="true">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ognlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="phpExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="propertyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="pythonExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="rubyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="simpleExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="sqlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="tokenizerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expression">
        <xs:attribute name="token" type="xs:string" use="required"/>
        <xs:attribute name="headerName" type="xs:string"/>
        <xs:attribute name="regex" type="xs:boolean"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="resultType" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xQueryExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="type" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="camelBeanPostProcessor"/>

  <xs:complexType name="camelConsumerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element ref="tns:properties" minOccurs="0"/>
          <xs:element name="package" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:packageScan" minOccurs="0"/>
          <xs:element ref="tns:jmxAgent" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:beanPostProcessor"/>
            <xs:element ref="tns:template"/>
            <xs:element ref="tns:consumerTemplate"/>
            <xs:element ref="tns:proxy"/>
            <xs:element ref="tns:export"/>
          </xs:choice>
          <xs:element ref="tns:routeBuilder" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:endpoint" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:dataFormats" minOccurs="0"/>
          <xs:element ref="tns:onException" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:onCompletion" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:intercept" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:interceptFrom" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element name="interceptSendToEndpoint" type="tns:interceptSendToEndpointDefinition" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:route" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="trace" type="xs:boolean"/>
        <xs:attribute name="streamCache" type="xs:boolean"/>
        <xs:attribute name="delayer" type="xs:long"/>
        <xs:attribute name="handleFault" type="xs:boolean"/>
        <xs:attribute name="errorHandlerRef" type="xs:string"/>
        <xs:attribute name="shouldStartContext" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelJMXAgentDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="disabled" type="xs:boolean"/>
        <xs:attribute name="onlyRegisterProcessorWithCustomId" type="xs:boolean"/>
        <xs:attribute name="registryPort" type="xs:int"/>
        <xs:attribute name="connectorPort" type="xs:int"/>
        <xs:attribute name="mbeanServerDefaultDomain" type="xs:string"/>
        <xs:attribute name="mbeanObjectDomainName" type="xs:string"/>
        <xs:attribute name="serviceUrlPath" type="xs:string"/>
        <xs:attribute name="createConnector" type="xs:boolean"/>
        <xs:attribute name="usePlatformMBeanServer" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProducerTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="defaultEndpoint" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProxyFactoryDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="serviceUrl" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelServiceExporterDefinition">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="serviceRef" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelEndpointFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="exchangePattern">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OutOptionalIn"/>
      <xs:enumeration value="OutIn"/>
      <xs:enumeration value="RobustOutOnly"/>
      <xs:enumeration value="OutOnly"/>
      <xs:enumeration value="InOptionalOut"/>
      <xs:enumeration value="InOut"/>
      <xs:enumeration value="RobustInOnly"/>
      <xs:enumeration value="InOnly"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="artixDSContentType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="TagValuePair"/>
      <xs:enumeration value="Sax"/>
      <xs:enumeration value="Xml"/>
      <xs:enumeration value="Java"/>
      <xs:enumeration value="Text"/>
      <xs:enumeration value="Binary"/>
      <xs:enumeration value="Auto"/>
      <xs:enumeration value="Default"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="loggingLevel">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OFF"/>
      <xs:enumeration value="WARN"/>
      <xs:enumeration value="TRACE"/>
      <xs:enumeration value="INFO"/>
      <xs:enumeration value="FATAL"/>
      <xs:enumeration value="ERROR"/>
      <xs:enumeration value="DEBUG"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="waitForTaskToComplete">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Always"/>
      <xs:enumeration value="IfReplyExpected"/>
      <xs:enumeration value="Never"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="bindyType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="KeyValue"/>
      <xs:enumeration value="Csv"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="jsonLibrary">
    <xs:restriction base="xs:string">
      <xs:enumeration value="Jackson"/>
      <xs:enumeration value="XStream"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>

